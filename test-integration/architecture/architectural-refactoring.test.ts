/**
 * BDD Tests: Architectural Refactoring
 *
 * Generated by: /3_define_test_cases
 * Last updated: 2025-12-21
 * Test coverage: Type system modularisation, error handling standardisation, and function decomposition
 */

import { test, describe, beforeEach, afterEach } from "node:test";
import { createDeepAgent } from "@/agent.ts";
import { StateBackend } from "@/backends/state.ts";
import { FilesystemBackend } from "@/backends/filesystem.ts";
import { createAnthropic } from '@ai-sdk/anthropic';
import type {
  DeepAgentState,
  CreateDeepAgentParams,
  WriteResult,
  EditResult,
  BackendProtocol,
  SubAgent,
  TodoItem,
  DeepAgentEvent
} from "@/types.ts";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as os from "node:os";
import assert from "node:assert/strict";

type TestCallback = () => void | Promise<void>;
type TestOptions = { timeout?: number } & Record<string, unknown>;

const skipIf = (condition: boolean) => {
  const runner = condition ? test.skip : test;
  return (name: string, fn: TestCallback, options?: TestOptions) => {
    if (options) {
      runner(name, options, fn);
      return;
    }
    runner(name, fn);
  };
};

// Skip integration tests without API key
const hasApiKey = !!process.env.ANTHROPIC_API_KEY;

// ============================================================================
// Test Helpers and Factories (Used 3+ times across tests)
// ============================================================================

/** Creates a test agent state with minimal setup - used 15+ times */
function createTestState(): DeepAgentState {
  return {
    files: {},
    todos: [],
  };
}

/** Creates a test backend with predefined state - used 12+ times */
function createTestBackend(state?: DeepAgentState): StateBackend {
  return new StateBackend(state || createTestState());
}

/** Creates a test agent with defaults - used 10+ times */
function createTestAgent(overrides?: Partial<CreateDeepAgentParams>) {
  return createDeepAgent({
    model: createAnthropic({
      baseURL: 'https://api.anthropic.com/v1',
    })(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
    backend: createTestBackend(),
    ...overrides,
  });
}

/** Creates event collector for testing event streams - used 6+ times */
function createEventCollector() {
  const events: DeepAgentEvent[] = [];
  const onEvent = (event: DeepAgentEvent) => events.push(event);
  return { events, onEvent };
}

/** Creates a temporary directory for filesystem tests - used 4+ times */
async function createTempDir(): Promise<string> {
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "arch-test-"));
  return tempDir;
}

/** Cleans up temporary directory - used 4+ times */
async function cleanupTempDir(tempDir: string): Promise<void> {
  await fs.rm(tempDir, { recursive: true, force: true });
}

// ============================================================================
// Phase 1: Type System Modularisation
// ============================================================================

describe("Phase 1: Type System Modularisation", () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe("Core Types Module", () => {
    test("should export all core agent configuration types", () => {
      // Given: Import from types (should work after modularisation)

      // When: Creating typed objects
      const config: CreateDeepAgentParams = {
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        backend: createTestBackend(),
      };

      const state: DeepAgentState = createTestState();

      const todo: TodoItem = {
        id: "test-1",
        content: "Test todo",
        status: "pending",
      };

      // Then: Types should be properly defined
      assert.notStrictEqual(config.model, undefined);
      assert.notStrictEqual(config.backend, undefined);
      assert.deepStrictEqual(state.files, {});
      assert.deepStrictEqual(state.todos, []);
      assert.strictEqual(todo.id, "test-1");
      assert.strictEqual(todo.status, "pending");
    });

    test("should maintain type safety for complex nested configurations", () => {
      // Given: Complex agent configuration
      const complexConfig: CreateDeepAgentParams = {
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        backend: createTestBackend(),
        subagents: [{
          name: "test-subagent",
          description: "Test subagent for codebase analysis",
          systemPrompt: "You are a codebase analysis specialist",
          tools: { read_file: {} as any, glob: {} as any }, // Simplified for test
        }],
      };

      // When: Creating agent with complex config
      const agent = createDeepAgent(complexConfig);

      // Then: Agent should be created successfully with all properties
      assert.notStrictEqual(agent, undefined);
      assert.notStrictEqual(complexConfig.subagents, undefined);
      assert.strictEqual(complexConfig.subagents?.length, 1);
      assert.strictEqual(complexConfig.subagents?.[0]?.name, "test-subagent");
    });
  });

  describe("Backend Types Module", () => {
    test("should export all backend protocol interfaces", async () => {
      // Given: Multiple backend types
      const stateBackend: BackendProtocol = new StateBackend(createTestState());
      const fsBackend: BackendProtocol = new FilesystemBackend({ rootDir: tempDir });

      // When: Testing backend compliance
      const testWrite = async (backend: BackendProtocol): Promise<WriteResult> => {
        return await backend.write("test.txt", "test content");
      };

      // Then: All backends should implement the protocol correctly
      const stateResult = await testWrite(stateBackend);
      const fsResult = await testWrite(fsBackend);

      assert.notStrictEqual(stateResult, undefined);
      assert.notStrictEqual(fsResult, undefined);
      assert.strictEqual(typeof stateResult.path, "string");
      assert.strictEqual(typeof fsResult.path, "string");
    });

    test("should maintain compatibility between different backend implementations", async () => {
      // Given: Multiple backend implementations
      const backends: BackendProtocol[] = [
        new StateBackend(createTestState()),
        new FilesystemBackend({ rootDir: tempDir }),
      ];

      // When: Performing operations on all backends
      for (const backend of backends) {
        // Write operation
        const writeResult = await backend.write("test.txt", "test content");
        assert.strictEqual(writeResult.path, "test.txt");

        // Read operation
        const readResult = await backend.read("test.txt");
        // Both backends format read results with line numbers for better agent UX
        assert.ok(readResult.includes("test content"));
        assert.match(readResult, /\d+\s+test content/);
      }

      // Then: All operations should work consistently across implementations
      assert.strictEqual(backends.length, 2);
    });
  });

  describe("Events Types Module", () => {
    test("should export all event types for comprehensive coverage", () => {
      // Given: Event collector
      const { events, onEvent } = createEventCollector();

      // When: Collecting different event types
      const testEvents: DeepAgentEvent[] = [
        { type: "text", text: "Test text" },
        { type: "tool-call", toolCallId: "test", toolName: "test_tool", args: {} },
        { type: "tool-result", toolCallId: "test", toolName: "test_tool", result: "success" },
        { type: "error", error: new Error("Test error") },
        { type: "done", state: createTestState() },
      ];

      testEvents.forEach(onEvent);

      // Then: All event types should be properly typed and collected
      assert.strictEqual(events.length, 5);
      assert.strictEqual(events[0]?.type, "text");
      assert.strictEqual(events[1]?.type, "tool-call");
      assert.strictEqual(events[2]?.type, "tool-result");
      assert.strictEqual(events[3]?.type, "error");
      assert.strictEqual(events[4]?.type, "done");
    });

    test("should maintain event type safety with discriminated unions", () => {
      // Given: Mixed events
      const events: DeepAgentEvent[] = [
        { type: "text", text: "Test text" },
        { type: "tool-call", toolCallId: "test", toolName: "test_tool", args: {} },
        { type: "error", error: new Error("Test error") },
      ];

      // When: Processing events with type guards
      const textEvents = events.filter(e => e.type === "text");
      const toolEvents = events.filter(e => e.type === "tool-call");
      const errorEvents = events.filter(e => e.type === "error");

      // Then: TypeScript should narrow types correctly
      assert.strictEqual(textEvents.length, 1);
      assert.ok(Object.prototype.hasOwnProperty.call(textEvents[0], "text"));

      assert.strictEqual(toolEvents.length, 1);
      assert.ok(Object.prototype.hasOwnProperty.call(toolEvents[0], "toolCallId"));

      assert.strictEqual(errorEvents.length, 1);
      assert.ok(Object.prototype.hasOwnProperty.call(errorEvents[0], "error"));
    });
  });

  describe("Subagent Types Module", () => {
    test("should export subagent infrastructure types", () => {
      // Given: Subagent configuration
      const subagent: SubAgent = {
        name: "test-subagent",
        description: "Test subagent for analysis",
        systemPrompt: "You are a test subagent",
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        tools: { read_file: {} as any, glob: {} as any, grep: {} as any },
      };

      // When: Creating agent with subagents
      const agent = createDeepAgent({
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        backend: createTestBackend(),
        subagents: [subagent],
      });

      // Then: Subagent types should be properly enforced
      assert.notStrictEqual(agent, undefined);
      assert.strictEqual(subagent.name, "test-subagent");
      assert.strictEqual(subagent.description, "Test subagent for analysis");
      assert.strictEqual(subagent.systemPrompt, "You are a test subagent");
      assert.ok(Object.prototype.hasOwnProperty.call(subagent.tools, "read_file"));
    });

    test("should validate subagent tool configurations", () => {
      // Given: Different subagent configurations
      const subagents: SubAgent[] = [
        {
          name: "analyzer",
          description: "Codebase analyzer",
          systemPrompt: "You analyze codebases",
          model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
          tools: { read_file: {} as any, glob: {} as any, grep: {} as any },
        },
        {
          name: "researcher",
          description: "Web researcher",
          systemPrompt: "You research topics using web tools",
          model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
          tools: { web_search: {} as any, web_fetch: {} as any },
        },
      ];

      // When: Creating agents with different subagent configs
      const agents = subagents.map(subagent =>
        createDeepAgent({
          model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
          backend: createTestBackend(),
          subagents: [subagent],
        })
      );

      // Then: All configurations should be valid
      assert.strictEqual(agents.length, 2);
      assert.notStrictEqual(agents[0], undefined);
      assert.notStrictEqual(agents[1], undefined);
    });
  });

  describe("Backward Compatibility", () => {
    test("should maintain all existing exports from types.ts", () => {
      // Given: Import from main types file (should re-export everything)

      // When: Using types as before refactoring
      const agent = createTestAgent();

      // Then: All types should be available without import path changes
      assert.notStrictEqual(agent, undefined);
      assert.notStrictEqual(agent.generate, undefined);
      assert.notStrictEqual(agent.stream, undefined);
    });

    test("should maintain type access after modularisation", async () => {
      // Given: Direct imports from types
      const types = await import("../../src/types.ts");

      // When: Creating typed objects
      const state = createTestState() as any;

      // Then: Types should work regardless of import path
      assert.notStrictEqual(state, undefined);
      assert.notStrictEqual(state.files, undefined);
      assert.notStrictEqual(state.todos, undefined);
    });
  });
});

// ============================================================================
// Phase 2: Error Handling Standardisation
// ============================================================================

describe("Phase 2: Error Handling Standardisation", () => {
  let tempDir: string;
  let stateBackend: StateBackend;
  let fsBackend: FilesystemBackend;

  beforeEach(async () => {
    tempDir = await createTempDir();
    stateBackend = createTestBackend();
    fsBackend = new FilesystemBackend({ rootDir: tempDir });
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe("WriteResult Interface", () => {
    test("should maintain backward compatibility with current WriteResult structure", async () => {
      // Given: Multiple backend implementations
      const backends = [stateBackend, fsBackend];

      for (const backend of backends) {
        // When: Writing a file
        const result = await backend.write("test.txt", "test content");

        // Then: Result should maintain current structure
        assert.ok(Object.prototype.hasOwnProperty.call(result, "path"));
        if (result.error) {
          assert.strictEqual(typeof result.error, "string");
          assert.strictEqual(result.path, undefined);
        } else {
          assert.strictEqual(typeof result.path, "string");
          assert.strictEqual(result.error, undefined);
        }
      }
    });

    test("should return path for successful writes", async () => {
      // Given: Valid file content
      const content = "Test file content";

      // When: Writing to different backends
      const stateResult = await stateBackend.write("success.txt", content);
      const fsResult = await fsBackend.write("success.txt", content);

      // Then: Both should return path without error
      assert.strictEqual(stateResult.path, "success.txt");
      assert.strictEqual(fsResult.path, "success.txt");
      assert.strictEqual(stateResult.error, undefined);
      assert.strictEqual(fsResult.error, undefined);
    });

    test("should return error for failed writes", async () => {
      // Given: State backend with existing file
      await stateBackend.write("exists.txt", "original");

      // When: Attempting to write to same file (should fail for state backend)
      const duplicateResult = await stateBackend.write("exists.txt", "duplicate");

      // Then: Should return error without path
      assert.ok(duplicateResult.error);
      assert.ok(duplicateResult.error.includes("already exists"));
      assert.strictEqual(duplicateResult.path, undefined);
    });

    test("should maintain compatibility with existing error checking patterns", async () => {
      // Given: Backend that might fail
      const backend = stateBackend;
      await backend.write("existing.txt", "content");

      // When: Using current error checking pattern
      const result = await backend.write("existing.txt", "new content");

      // Then: Current pattern should work (will be enhanced with success field later)
      if (result.error) {
        assert.ok(result.error.includes("already exists"));
        assert.strictEqual(result.path, undefined);
      } else {
        // Should not reach here for this test case
        assert.strictEqual(true, false);
      }
    });
  });

  describe("EditResult Interface", () => {
    test("should maintain backward compatibility with current EditResult structure", async () => {
      // Given: Files to edit
      await stateBackend.write("edit-test.txt", "original content");
      await fsBackend.write("edit-test.txt", "original content");

      // When: Editing files
      const stateResult = await stateBackend.edit("edit-test.txt", "original", "modified");
      const fsResult = await fsBackend.edit("edit-test.txt", "original", "modified");

      // Then: Results should maintain current structure
      assert.ok(Object.prototype.hasOwnProperty.call(stateResult, "path"));
      assert.ok(Object.prototype.hasOwnProperty.call(fsResult, "path"));
      if (stateResult.error) {
        assert.strictEqual(typeof stateResult.error, "string");
        assert.strictEqual(stateResult.path, undefined);
      } else {
        assert.strictEqual(typeof stateResult.path, "string");
        assert.strictEqual(stateResult.error, undefined);
      }
    });

    test("should return path for successful edits", async () => {
      // Given: File with editable content
      await stateBackend.write("editable.txt", "Original content");

      // When: Performing successful edit
      const result = await stateBackend.edit("editable.txt", "Original", "Modified");

      // Then: Should report success with metrics
      assert.strictEqual(result.path, "editable.txt");
      assert.strictEqual(result.occurrences, 1);
      assert.strictEqual(result.error, undefined);
    });

    test("should return error for failed edits", async () => {
      // Given: File without target text
      await stateBackend.write("no-match.txt", "Different content");

      // When: Attempting edit with non-existent text
      const result = await stateBackend.edit("no-match.txt", "not found", "replacement");

      // Then: Should report failure
      assert.ok(result.error);
      assert.ok(result.error.includes("not found"));
      assert.strictEqual(result.path, undefined);
      assert.strictEqual(result.occurrences, undefined);
    });
  });

  describe("Consistent Error Patterns", () => {
    test("should handle file not found consistently", async () => {
      // Given: Non-existent file
      const nonExistentFile = "does-not-exist.txt";

      // When: Attempting operations on non-existent file
      const readResult = await stateBackend.read(nonExistentFile);
      const editResult = await stateBackend.edit(nonExistentFile, "test", "test");

      // Then: Both should return error strings
      assert.strictEqual(typeof readResult, "string");
      assert.ok(readResult.includes("not found"));
      assert.ok(editResult.error);
      assert.ok(editResult.error.includes("not found"));
    });

    test("should handle invalid operations gracefully", async () => {
      // Given: Empty file path
      const invalidPath = "";

      // When: Attempting operations with invalid path
      const writeResult = await stateBackend.write(invalidPath, "content");

      // Then: Should return structured error
      assert.notStrictEqual(writeResult.error, undefined);
      assert.strictEqual(writeResult.path, undefined);
    });
  });
});

// ============================================================================
// Phase 3: Function Decomposition
// ============================================================================

describe("Phase 3: Function Decomposition", () => {
  skipIf(!hasApiKey)("should break down streamWithEvents into focused methods", async () => {
    // Given: Agent instance
    const agent = createTestAgent();
    const events: DeepAgentEvent[] = [];

    // When: Streaming with events (tests refactored streamWithEvents implementation)
    for await (const event of agent.streamWithEvents({ prompt: "Simple test" })) {
      events.push(event);
      if (event.type === "done") break;
    }

    // Then: Should receive expected event sequence
    assert.ok(events.length > 0);
    assert.ok(events.some(e => e.type === "done"));
  });

  test("should decompose createTools into logical groupings", () => {
    // Given: Agent with multiple tool categories
    const agent = createDeepAgent({
      model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
      backend: createTestBackend(),
    });

    // When: Accessing agent's tools (will use refactored createTools)
    // Note: This tests the interface, implementation details tested separately

    // Then: Agent should be created successfully
    assert.notStrictEqual(agent, undefined);
  });

  test("should maintain identical behavior after decomposition", async () => {
    // Given: Multiple agents with same configuration
    const config = {
      model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
      backend: createTestBackend(),
    };

    // When: Creating agents with same config
    const agent1 = createDeepAgent(config);
    const agent2 = createDeepAgent(config);

    // Then: Should have identical capabilities
    assert.notStrictEqual(agent1.generate, undefined);
    assert.notStrictEqual(agent2.generate, undefined);
    assert.notStrictEqual(agent1.stream, undefined);
    assert.notStrictEqual(agent2.stream, undefined);
  });
});

// ============================================================================
// Integration Tests (Real API)
// ============================================================================

describe("Integration Tests", () => {
  let agent: ReturnType<typeof createDeepAgent>;

  beforeEach(() => {
    agent = createTestAgent();
  });

  skipIf(!hasApiKey)(
    "end-to-end test with all architectural improvements",
    async () => {
      // Given: Real agent with modularized types
      const events: DeepAgentEvent[] = [];

      // When: Performing complex operation with event streaming
      for await (const event of agent.streamWithEvents({ prompt: "Write a hello world function in JavaScript" })) {
        events.push(event);
        if (event.type === "done") break;
      }

      // Then: Should work seamlessly with new architecture
      const doneEvent = events.find(e => e.type === "done");
      assert.notStrictEqual(doneEvent, undefined);
      if (doneEvent && doneEvent.type === "done" && doneEvent.text) {
        assert.ok(doneEvent.text.length > 0);
      }
      assert.ok(events.length > 0);
    },
    { timeout: 30000 }
  );

  skipIf(!hasApiKey)(
    "error handling works in real environment",
    async () => {
      // Given: Agent for integration testing
      const agent = createTestAgent();

      // When: Making request that might trigger various paths
      const result = await agent.generate({
        prompt: "List files in current directory"
      });

      // Then: Should handle errors gracefully
      assert.notStrictEqual(result.text, undefined);
      // Should not crash or hang
    },
    { timeout: 30000 }
  );
});

// ============================================================================
// Performance and Compatibility Tests
// ============================================================================

describe("Performance and Compatibility", () => {
  test("should not introduce performance regressions", () => {
    // Given: Large number of type imports
    const start = performance.now();

    // When: Importing all modularized types
    import("../../src/types.ts");

    const end = performance.now();
    const importTime = end - start;

    // Then: Import time should be reasonable (< 100ms)
    assert.ok(importTime < 100);
  });

  test("should maintain type checking performance", () => {
    // Given: Complex type usage
    const complexConfig: CreateDeepAgentParams = {
      model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
      backend: createTestBackend(),
      subagents: Array(10).fill(null).map((_, i) => ({
        name: `agent-${i}`,
        description: `Agent ${i} for testing`,
        systemPrompt: `You are agent ${i}`,
        tools: { read_file: {} as any, write_file: {} as any },
      })),
    };

    // When: Creating agent with complex configuration
    const agent = createDeepAgent(complexConfig);

    // Then: Should be created without type errors
    assert.notStrictEqual(agent, undefined);
    assert.ok(complexConfig.subagents);
    assert.strictEqual(complexConfig.subagents.length, 10);
  });

  test("should support gradual migration", () => {
    // Given: Mixed import patterns
    import("../../src/types.ts");

    // When: Using types from different import styles
    const state1: DeepAgentState = createTestState();
    const state2: DeepAgentState = createTestState();

    // Then: Should work interchangeably
    assert.deepStrictEqual(state1, state2);
    assert.deepStrictEqual(state1.files, state2.files);
    assert.deepStrictEqual(state1.todos, state2.todos);
  });
});