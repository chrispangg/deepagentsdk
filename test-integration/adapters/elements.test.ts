/**
 * BDD Tests: AI SDK Elements Integration - Phase 1 (Adapter Hook)
 *
 * Generated by: /3_define_test_cases
 * Ticket: 018_ai_sdk_elements_integration
 * Last updated: 2026-01-08
 * Test coverage: useElementsAdapter hook, message transformation, status mapping, tool parts conversion
 */

// Setup jsdom for React testing
import { JSDOM } from "jsdom";
const dom = new JSDOM("<!DOCTYPE html><html><body></body></html>", {
  url: "http://localhost",
});
global.document = dom.window.document;
global.window = dom.window as any;

import { test, expect, describe, beforeEach } from "bun:test";
import { renderHook, act, waitFor } from "@testing-library/react";
import { useElementsAdapter } from "@/adapters/elements";
import { StateBackend } from "@/backends/state";
import { anthropic } from "@ai-sdk/anthropic";
import type { DeepAgentState, TodoItem } from "@/types";
import type { UIMessage, UIMessagePart } from "@/adapters/elements/types";
import type { LanguageModelV3 } from "@ai-sdk/provider";
import { z } from "zod";

// ============================================================================
// Test Helpers (Used 3+ times across tests)
// ============================================================================

/** Creates fresh StateBackend for testing (used 15+ times) */
function createMockBackend(state?: DeepAgentState): StateBackend {
  return new StateBackend(
    state ?? {
      todos: [],
      files: {},
    }
  );
}

/** Creates todo item for testing (used 5+ times) */
function createMockTodo(
  content: string,
  status: TodoItem["status"] = "pending"
): TodoItem {
  return {
    id: `todo-${Date.now()}-${Math.random()}`,
    content,
    status,
  };
}

/** Mock usage for testing */
const mockUsage = {
  inputTokens: {
    total: 5,
    noCache: 5,
    cacheRead: undefined,
    cacheWrite: undefined,
  },
  outputTokens: { total: 5, text: 5, reasoning: undefined },
};

/** Mock language model for testing (used 10+ times) */
const mockModel: LanguageModelV3 = {
  provider: "test",
  modelId: "test-model",
  specificationVersion: "v3",
  supportedUrls: {},
  doGenerate: async () => ({
    content: [{ type: "text", text: "Mock response" }],
    usage: mockUsage,
    finishReason: { unified: "stop", raw: undefined },
    warnings: [],
  }),
  doStream: async () => ({
    stream: new ReadableStream({
      async start(controller) {
        // Simulate realistic streaming with text chunks
        controller.enqueue({
          type: "text-delta" as const,
          id: "text-1",
          delta: "Mock ",
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        controller.enqueue({
          type: "text-delta" as const,
          id: "text-1",
          delta: "response ",
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        controller.enqueue({
          type: "text-delta" as const,
          id: "text-1",
          delta: "text",
        });
        await new Promise(resolve => setTimeout(resolve, 10));
        controller.enqueue({
          type: "finish" as const,
          finishReason: { unified: "stop" as const, raw: undefined },
          usage: mockUsage,
        });
        controller.close();
      },
    }),
  }),
};

/**
 * Creates a mock model that emits tool calls.
 * Used for testing tool call and tool result handling.
 *
 * @param toolName - Name of the tool to call
 * @param toolArgs - Arguments to pass to the tool (will be stringified)
 * @param responseText - Text response after tool execution
 */
function createMockModelWithToolCall(
  toolName: string,
  toolArgs: Record<string, unknown> = {},
  responseText: string = "Tool execution complete"
): LanguageModelV3 {
  return {
    provider: "test",
    modelId: "test-model-with-tools",
    specificationVersion: "v3",
    supportedUrls: {},
    doGenerate: async () => ({
      content: [{ type: "text", text: responseText }],
      usage: mockUsage,
      finishReason: { unified: "stop", raw: undefined },
      warnings: [],
    }),
    doStream: async () => ({
      stream: new ReadableStream({
        async start(controller) {
          const toolCallId = `tc-${Date.now()}`;

          // Emit tool call
          controller.enqueue({
            type: "tool-call" as const,
            toolCallId,
            toolName,
            input: JSON.stringify(toolArgs),
          });

          // Emit text response
          controller.enqueue({
            type: "text-delta" as const,
            id: "text-1",
            delta: responseText,
          });

          // Finish
          controller.enqueue({
            type: "finish" as const,
            finishReason: { unified: "stop" as const, raw: undefined },
            usage: mockUsage,
          });
          controller.close();
        },
      }),
    }),
  };
}

// ============================================================================
// Phase 1.1: useElementsAdapter Hook Initialization
// ============================================================================

describe("Phase 1.1: useElementsAdapter Hook Initialization", () => {
  test("should initialize with empty messages and ready status", () => {
    // Given: Fresh backend with no state
    const backend = createMockBackend();

    // When: Rendering the hook
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // Then: Should start with empty messages and ready status
    expect(result.current.uiMessages).toEqual([]);
    expect(result.current.uiStatus).toBe("ready");
    expect(result.current.toolParts).toEqual([]);
  });

  test("should provide sendMessage callback", () => {
    // Given: Initialized adapter
    const backend = createMockBackend();

    // When: Rendering the hook
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // Then: Should expose sendMessage function
    expect(result.current.sendMessage).toBeDefined();
    expect(typeof result.current.sendMessage).toBe("function");
  });

  test("should provide abort and clear callbacks", () => {
    // Given: Initialized adapter
    const backend = createMockBackend();

    // When: Rendering the hook
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // Then: Should expose control functions
    expect(result.current.abort).toBeDefined();
    expect(result.current.clear).toBeDefined();
    expect(typeof result.current.abort).toBe("function");
    expect(typeof result.current.clear).toBe("function");
  });
});

// ============================================================================
// Phase 1.2: Message Transformation - Text Events
// ============================================================================

describe("Phase 1.2: Message Transformation - Text Events", () => {
  test("should convert user message to UIMessage with text part", async () => {
    // Given: Adapter with mock backend
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending a message
    await act(async () => {
      await result.current.sendMessage({ text: "Hello" });
    });

    // Then: Should create user message with text part
    await waitFor(() => {
      expect(result.current.uiMessages.length).toBeGreaterThan(0);
    });

    const userMessage = result.current.uiMessages.find(
      (m) => m.role === "user"
    );
    expect(userMessage).toBeDefined();
    expect(userMessage?.parts).toHaveLength(1);
    expect(userMessage?.parts[0]).toEqual({
      type: "text",
      text: "Hello",
    });
  });

  test("should accumulate streaming text chunks into text parts", async () => {
    // Given: Adapter that will receive streaming text
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending message and receiving streamed response
    await act(async () => {
      await result.current.sendMessage({ text: "Tell me a story" });
    });

    // Then: Should combine text chunks into single text part
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      expect(assistantMessage).toBeDefined();
      expect(assistantMessage?.parts.some((p) => p.type === "text")).toBe(
        true
      );
    });
  });

  test("should create separate text parts for text-segment events", async () => {
    // Given: Adapter receiving multiple text segments
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Events include multiple text-segment events
    await act(async () => {
      await result.current.sendMessage({ text: "Multi-segment test" });
    });

    // Then: Each segment should become a text part
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      const textParts = assistantMessage?.parts.filter(
        (p) => p.type === "text"
      );
      expect(textParts).toBeDefined();
      expect(textParts!.length).toBeGreaterThan(0);
    });
  });
});

// ============================================================================
// Phase 1.3: Message Transformation - Tool Call Events
// ============================================================================

describe("Phase 1.3: Message Transformation - Tool Call Events", () => {
  test("should convert tool-call event to tool-call part", async () => {
    // Given: Adapter that will trigger tool call
    const backend = createMockBackend();
    const toolCallModel = createMockModelWithToolCall("test_tool", {});
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: toolCallModel,
        backend,
        tools: {
          test_tool: {
            description: "Test tool",
            inputSchema: z.object({}),
            execute: async () => "result",
          },
        },
      })
    );

    // When: Sending message that triggers tool
    await act(async () => {
      await result.current.sendMessage({ text: "Use test tool" });
    });

    // Then: Should create tool-call part
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      const toolCallPart = assistantMessage?.parts.find(
        (p) => p.type === "tool-call"
      );
      expect(toolCallPart).toBeDefined();
      expect(toolCallPart).toHaveProperty("toolName");
      expect(toolCallPart).toHaveProperty("toolCallId");
      expect(toolCallPart).toHaveProperty("args");
    });
  });

  test("should convert tool-result event to tool-result part", async () => {
    // Given: Adapter that executed tool call
    const backend = createMockBackend();
    const toolCallModel = createMockModelWithToolCall("test_tool", {});
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: toolCallModel,
        backend,
        tools: {
          test_tool: {
            description: "Test tool",
            inputSchema: z.object({}),
            execute: async () => "Tool result",
          },
        },
      })
    );

    // When: Tool call completes
    await act(async () => {
      await result.current.sendMessage({ text: "Execute tool" });
    });

    // Then: Should create tool-result part
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      const toolResultPart = assistantMessage?.parts.find(
        (p) => p.type === "tool-result"
      );
      expect(toolResultPart).toBeDefined();
      expect(toolResultPart).toHaveProperty("toolCallId");
      expect(toolResultPart).toHaveProperty("result");
    });
  });

  test("should match tool-call and tool-result by toolCallId", async () => {
    // Given: Adapter with tool that will be called and return result
    const backend = createMockBackend();
    const toolCallModel = createMockModelWithToolCall("calculator", { expr: "2+2" });
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: toolCallModel,
        backend,
        tools: {
          calculator: {
            description: "Calculator",
            inputSchema: z.object({
              expr: z.string(),
            }),
            execute: async ({ expr }) => `Result: ${expr}`,
          },
        },
      })
    );

    // When: Tool is called and completes
    await act(async () => {
      await result.current.sendMessage({ text: "Calculate 2+2" });
    });

    // Then: Tool call and result should have matching toolCallId
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      const toolCallPart = assistantMessage?.parts.find(
        (p) => p.type === "tool-call"
      ) as any;
      const toolResultPart = assistantMessage?.parts.find(
        (p) => p.type === "tool-result"
      ) as any;

      if (toolCallPart && toolResultPart) {
        expect(toolCallPart.toolCallId).toBe(toolResultPart.toolCallId);
      }
    });
  });

  test("should preserve tool call args in tool-call part", async () => {
    // Given: Adapter with tool that receives arguments
    const backend = createMockBackend();
    const expectedArgs = { query: "test query" };
    const toolCallModel = createMockModelWithToolCall("search", expectedArgs);
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: toolCallModel,
        backend,
        tools: {
          search: {
            description: "Search tool",
            inputSchema: z.object({
              query: z.string(),
            }),
            execute: async ({ query }) => `Results for ${query}`,
          },
        },
      })
    );

    // When: Tool is called with arguments
    await act(async () => {
      await result.current.sendMessage({ text: "Search for test query" });
    });

    // Then: Args should be preserved in tool-call part
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      const toolCallPart = assistantMessage?.parts.find(
        (p) => p.type === "tool-call"
      ) as any;
      expect(toolCallPart?.args).toBeDefined();
    });
  });
});

// ============================================================================
// Phase 1.4: Status Mapping
// ============================================================================

describe("Phase 1.4: Status Mapping", () => {
  test("should map 'idle' agent status to 'ready' UI status", () => {
    // Given: Adapter in idle state
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Hook initializes (idle state)
    // Then: Should map to ready
    expect(result.current.uiStatus).toBe("ready");
  });

  test("should map 'thinking' agent status to 'submitted' UI status", async () => {
    // Given: Adapter that will enter thinking state
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Message is submitted (thinking phase)
    act(() => {
      result.current.sendMessage({ text: "Think about this" });
    });

    // Then: Should map to submitted
    await waitFor(() => {
      expect(result.current.uiStatus).toBe("submitted");
    });
  });

  test("should map 'streaming' agent status to 'streaming' UI status", async () => {
    // Given: Adapter receiving streaming response
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Agent is streaming response
    act(() => {
      result.current.sendMessage({ text: "Tell me a story" });
    });

    // Then: Should map to streaming
    await waitFor(() => {
      expect(result.current.uiStatus).toBe("streaming");
    });
  });

  test("should map 'tool-call' agent status to 'submitted' UI status", async () => {
    // Given: Adapter executing tool
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: mockModel,
        backend,
        tools: {
          slow_tool: {
            description: "Slow tool",
            inputSchema: z.object({}),
            execute: async () => {
              await new Promise((resolve) => setTimeout(resolve, 100));
              return "done";
            },
          },
        },
      })
    );

    // When: Tool is being called
    act(() => {
      result.current.sendMessage({ text: "Use slow tool" });
    });

    // Then: Should map to submitted during tool execution
    await waitFor(() => {
      expect(result.current.uiStatus).toBe("submitted");
    });
  });

  test("should map 'error' agent status to 'error' UI status", async () => {
    // Given: Adapter that will encounter error
    const backend = createMockBackend();
    const errorModel = {
      ...mockModel,
      doGenerate: async () => {
        throw new Error("Test error");
      },
    };
    const { result } = renderHook(() =>
      useElementsAdapter({ model: errorModel, backend })
    );

    // When: Error occurs during generation
    await act(async () => {
      try {
        await result.current.sendMessage({ text: "Cause error" });
      } catch (e) {
        // Expected error
      }
    });

    // Then: Should map to error status
    await waitFor(() => {
      expect(result.current.uiStatus).toBe("error");
    });
  });

  test("should map 'done' agent status to 'ready' UI status", async () => {
    // Given: Adapter that completes generation
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Generation completes
    await act(async () => {
      await result.current.sendMessage({ text: "Quick message" });
    });

    // Then: Should return to ready
    await waitFor(() => {
      expect(result.current.uiStatus).toBe("ready");
    });
  });
});

// ============================================================================
// Phase 1.5: Tool Parts Extraction
// ============================================================================

describe("Phase 1.5: Tool Parts Extraction", () => {
  test("should extract tool parts from current message", async () => {
    // Given: Adapter with tools
    const backend = createMockBackend();
    const toolCallModel = createMockModelWithToolCall("test_tool", {});
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: toolCallModel,
        backend,
        tools: {
          test_tool: {
            description: "Test",
            inputSchema: z.object({}),
            execute: async () => "result",
          },
        },
      })
    );

    // When: Tool is called
    await act(async () => {
      await result.current.sendMessage({ text: "Use tool" });
    });

    // Then: toolParts should contain tool call information
    await waitFor(() => {
      expect(result.current.toolParts.length).toBeGreaterThan(0);
    });
  });

  test("should provide tool parts with correct structure", async () => {
    // Given: Adapter that will call tool
    const backend = createMockBackend();
    const toolCallModel = createMockModelWithToolCall("calculator", { expr: "2+2" });
    const { result } = renderHook(() =>
      useElementsAdapter({
        model: toolCallModel,
        backend,
        tools: {
          calculator: {
            description: "Calculator",
            inputSchema: z.object({
              expr: z.string(),
            }),
            execute: async () => "42",
          },
        },
      })
    );

    // When: Tool call happens
    await act(async () => {
      await result.current.sendMessage({ text: "Calculate" });
    });

    // Then: Tool parts should have correct structure
    await waitFor(() => {
      const toolPart = result.current.toolParts[0];
      if (toolPart) {
        expect(toolPart).toHaveProperty("type");
        expect(toolPart.type).toMatch(/^(tool-call|tool-result)$/);
      }
    });
  });
});

// ============================================================================
// Phase 1.6: Message State Management
// ============================================================================

describe("Phase 1.6: Message State Management", () => {
  test("should maintain message history across multiple sends", async () => {
    // Given: Adapter for multi-turn conversation
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending multiple messages
    await act(async () => {
      await result.current.sendMessage({ text: "First message" });
    });
    await act(async () => {
      await result.current.sendMessage({ text: "Second message" });
    });

    // Then: Should maintain both messages in history
    expect(result.current.uiMessages.length).toBeGreaterThanOrEqual(4); // 2 user + 2 assistant
    const userMessages = result.current.uiMessages.filter(
      (m) => m.role === "user"
    );
    expect(userMessages).toHaveLength(2);
  });

  test("should clear messages when clear() is called", async () => {
    // Given: Adapter with existing messages
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    await act(async () => {
      await result.current.sendMessage({ text: "Message" });
    });

    // When: Calling clear
    act(() => {
      result.current.clear();
    });

    // Then: Messages should be cleared
    expect(result.current.uiMessages).toEqual([]);
    expect(result.current.uiStatus).toBe("ready");
  });

  test("should preserve message order (user, assistant, user, assistant)", async () => {
    // Given: Multi-turn conversation
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Multiple exchanges
    await act(async () => {
      await result.current.sendMessage({ text: "First" });
    });
    await act(async () => {
      await result.current.sendMessage({ text: "Second" });
    });

    // Then: Messages should alternate user/assistant
    const roles = result.current.uiMessages.map((m) => m.role);
    expect(roles[0]).toBe("user");
    expect(roles[1]).toBe("assistant");
    expect(roles[2]).toBe("user");
    expect(roles[3]).toBe("assistant");
  });
});

// ============================================================================
// Phase 1.7: Streaming Message Updates
// ============================================================================

describe("Phase 1.7: Streaming Message Updates", () => {
  test("should update streaming message status during generation", async () => {
    // Given: Adapter receiving streaming response
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Starting stream
    act(() => {
      result.current.sendMessage({ text: "Stream test" });
    });

    // Then: Last message should have streaming status
    await waitFor(() => {
      const lastMessage =
        result.current.uiMessages[result.current.uiMessages.length - 1];
      if (lastMessage?.role === "assistant") {
        expect(lastMessage.status).toBe("streaming");
      }
    });
  });

  test("should mark message as ready when streaming completes", async () => {
    // Given: Adapter that will complete streaming
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Stream completes
    await act(async () => {
      await result.current.sendMessage({ text: "Complete stream" });
    });

    // Then: Message should be marked ready
    await waitFor(() => {
      const assistantMessages = result.current.uiMessages.filter(
        (m) => m.role === "assistant"
      );
      const lastAssistant =
        assistantMessages[assistantMessages.length - 1];
      expect(lastAssistant?.status).toBe("ready");
    });
  });
});

// ============================================================================
// Phase 1.8: Abort Functionality
// ============================================================================

describe("Phase 1.8: Abort Functionality", () => {
  test("should abort streaming when abort() is called", async () => {
    // Given: Adapter with long-running stream
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Starting stream and aborting
    act(() => {
      result.current.sendMessage({ text: "Long message" });
    });

    await new Promise((resolve) => setTimeout(resolve, 50));

    act(() => {
      result.current.abort();
    });

    // Then: Status should return to ready
    await waitFor(() => {
      expect(result.current.uiStatus).toBe("ready");
    });
  });

  test("should preserve partial message after abort", async () => {
    // Given: Adapter with streaming in progress
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Aborting mid-stream
    act(() => {
      result.current.sendMessage({ text: "Partial" });
    });

    await new Promise((resolve) => setTimeout(resolve, 30));

    act(() => {
      result.current.abort();
    });

    // Then: Partial message should be preserved
    await waitFor(() => {
      const assistantMessage = result.current.uiMessages.find(
        (m) => m.role === "assistant"
      );
      expect(assistantMessage).toBeDefined();
    });
  });
});

// ============================================================================
// Phase 1.9: Integration with PromptInput Component
// ============================================================================

describe("Phase 1.9: Integration with PromptInput Component", () => {
  test("should accept PromptInputMessage format", async () => {
    // Given: Adapter ready to receive message
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending PromptInput-formatted message
    const promptInputMessage = {
      text: "Hello from PromptInput",
      files: [],
    };

    await act(async () => {
      await result.current.sendMessage(promptInputMessage);
    });

    // Then: Should process message correctly
    await waitFor(() => {
      const userMessage = result.current.uiMessages.find(
        (m) => m.role === "user"
      );
      expect(userMessage?.parts[0]).toEqual({
        type: "text",
        text: "Hello from PromptInput",
      });
    });
  });

  test("should handle empty text in PromptInputMessage", async () => {
    // Given: Adapter receiving empty message
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending message with empty text
    const emptyMessage = { text: "", files: [] };

    await act(async () => {
      await result.current.sendMessage(emptyMessage);
    });

    // Then: Should not create message or should handle gracefully
    // Implementation may choose to ignore empty messages
    expect(result.current.uiMessages.length).toBeGreaterThanOrEqual(0);
  });
});

// ============================================================================
// Phase 1.10: Edge Cases
// ============================================================================

describe("Phase 1.10: Edge Cases", () => {
  beforeEach(() => {
    // Clean up any leaked state between tests
    // This is needed because React's state can persist in the test environment
  });

  test("should handle rapid consecutive sends", async () => {
    // Given: Adapter receiving rapid messages
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending multiple messages quickly
    const promises = [
      act(async () => {
        await result.current.sendMessage({ text: "Message 1" });
      }),
      act(async () => {
        await result.current.sendMessage({ text: "Message 2" });
      }),
      act(async () => {
        await result.current.sendMessage({ text: "Message 3" });
      }),
    ];

    await Promise.all(promises);

    // Then: All messages should be processed
    expect(result.current.uiMessages.length).toBeGreaterThanOrEqual(3);
  });

  test("should handle message with no tool calls", async () => {
    // Given: Adapter without tools
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending message
    await act(async () => {
      await result.current.sendMessage({ text: "Simple message" });
    });

    // Then: Should have no tool parts
    expect(result.current.toolParts).toHaveLength(0);
  });

  test("should handle very long message content", async () => {
    // Given: Adapter receiving long message
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending very long message
    const longText = "Lorem ipsum ".repeat(1000);
    await act(async () => {
      await result.current.sendMessage({ text: longText });
    });

    // Then: Should process without error
    await waitFor(() => {
      const userMessage = result.current.uiMessages.find(
        (m) => m.role === "user"
      );
      expect(userMessage).toBeDefined();
    });
  });

  test("should handle unicode and special characters in messages", async () => {
    // Given: Adapter receiving special characters
    const backend = createMockBackend();
    const { result } = renderHook(() =>
      useElementsAdapter({ model: mockModel, backend })
    );

    // When: Sending message with unicode
    const unicodeMessage = "Hello ðŸ‘‹ ä¸–ç•Œ ðŸŒ Ù…Ø±Ø­Ø¨Ø§";
    await act(async () => {
      await result.current.sendMessage({ text: unicodeMessage });
    });

    // Then: Should preserve unicode correctly
    await waitFor(() => {
      const userMessage = result.current.uiMessages.find(
        (m) => m.role === "user"
      );
      expect(userMessage?.parts[0]).toEqual({
        type: "text",
        text: unicodeMessage,
      });
    });
  });
});
