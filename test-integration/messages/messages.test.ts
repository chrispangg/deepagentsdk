/**
 * BDD Tests: Hybrid Prompt-to-Messages API Implementation
 *
 * Generated by: /3_define_test_cases
 * Last updated: 2025-12-20
 * Test coverage: Phase 1 implementation of messages parameter in streamWithEvents
 *
 * These tests verify the hybrid API that supports both prompt (deprecated) and
 * messages parameters with proper priority logic: messages > prompt > checkpoint.
 */

import { test, describe, beforeEach } from "node:test";
import { createDeepAgent, StateBackend, MemorySaver } from "@/index.ts";
import type { ModelMessage } from "ai";
import { tool } from "ai";
import { z } from "zod";
import { createAnthropic } from '@ai-sdk/anthropic';
import assert from "node:assert/strict";
import { isDeepStrictEqual } from "node:util";
import { expect } from "expect";

// ============================================================================
// Test Setup & Configuration
// ============================================================================

const anthropic = createAnthropic({
  baseURL: 'https://api.anthropic.com/v1',
});

const hasApiKey = !!process.env.ANTHROPIC_API_KEY;

type TestCallback = () => void | Promise<void>;

const testWithApiKey = (
  name: string,
  fn: TestCallback,
  timeout?: number
) => {
  const runner = hasApiKey ? test : test.skip;
  if (timeout !== undefined) {
    runner(name, { timeout }, fn);
    return;
  }
  runner(name, fn);
};

// Create a mock tool for testing
const createMockTool = (name: string) =>
  tool({
    description: `Test tool: ${name}`,
    inputSchema: z.object({ input: z.string() }),
    execute: async ({ input }) => `Processed: ${input}`,
  });

// Create a mock state with todos and files
function createMockState(): { todos: any[]; files: Record<string, any> } {
  return {
    todos: [],
    files: {},
  };
}

// Create test checkpoint with messages
function createTestCheckpoint(
  threadId: string,
  messages: ModelMessage[] = [{ role: "user", content: "checkpoint message" }]
) {
  return {
    threadId,
    step: 1,
    messages,
    state: createMockState(),
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
}

function assertContainsMessage(messages: ModelMessage[], expected: ModelMessage) {
  assert.ok(messages.some(message => isDeepStrictEqual(message, expected)));
}

function assertNotContainsMessage(messages: ModelMessage[], expected: ModelMessage) {
  assert.ok(!messages.some(message => isDeepStrictEqual(message, expected)));
}

// ============================================================================
// Phase 1: Core Message Handling Tests
// ============================================================================

describe("Phase 1: Core Message Handling", () => {
  let backend: StateBackend;
  let agent: any;

  beforeEach(() => {
    backend = new StateBackend(createMockState());
    agent = createDeepAgent({
      model: anthropic("claude-haiku-4-5-20251001"),
      backend,
      checkpointer: new MemorySaver(),
      tools: {
        mockTool: createMockTool("mock"),
      },
    });
  });

  describe("Messages Parameter (Primary)", () => {
    testWithApiKey("uses messages parameter when provided", async () => {
      // Given: Messages array is provided
      const messages: ModelMessage[] = [
        { role: "user", content: "Hello world" }
      ];

      // When: Streaming with events
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        messages,
        threadId: `test-messages-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Messages should be included in final state
      assert.notStrictEqual(doneEvent, null);
      assertContainsMessage(doneEvent.messages, { role: "user", content: "Hello world" });
    }, 30000);

    testWithApiKey("handles multi-turn conversation with messages", async () => {
      // Given: Complete conversation history
      const messages: ModelMessage[] = [
        { role: "user", content: "What is 2+2?" },
        { role: "assistant", content: "2+2 equals 4." },
        { role: "user", content: "What about 3+3?" }
      ];

      // When: Streaming with conversation context
      let doneEvent: any = null;
      let textFound = false;

      for await (const event of agent.streamWithEvents({
        messages,
        threadId: `test-conversation-${Date.now()}`,
      })) {
        if (event.type === "text" && event.text.includes("6")) {
          textFound = true;
        }
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should respond with answer to last question
      assert.strictEqual(textFound, true);
      // Messages should include original messages plus assistant response
      assert.ok(doneEvent.messages.length > messages.length);
      // Original messages should be preserved
      messages.forEach(msg => {
        assertContainsMessage(doneEvent.messages, msg);
      });
    }, 30000);

    test("accepts empty messages array", { timeout: 30000 }, async () => {
      // Given: Empty messages array
      const messages: ModelMessage[] = [];

      // When: Streaming with empty messages
      let doneEvent: any = null;

      for await (const event of agent.streamWithEvents({
        messages,
        threadId: `test-empty-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should handle gracefully
      assert.notStrictEqual(doneEvent, null);
      assert.deepStrictEqual(doneEvent.messages, []);
    });
  });

  describe("Prompt Parameter (Backward Compatibility)", () => {
    testWithApiKey("converts prompt to user message for backward compatibility", async () => {
      // Given: Only prompt parameter is provided (old way)
      const prompt = "Hello from prompt";

      // When: Streaming with events
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        prompt,
        threadId: `test-prompt-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Prompt should be converted to user message
      assert.notStrictEqual(doneEvent, null);
      assertContainsMessage(doneEvent.messages, { role: "user", content: "Hello from prompt" });
    }, 30000);

    testWithApiKey("works with prompt and maxSteps", async () => {
      // Given: Prompt with additional options
      const prompt = "Create a todo item";

      // When: Streaming with maxSteps limit
      let doneEvent: any = null;
      let todosUpdated = false;

      for await (const event of agent.streamWithEvents({
        prompt,
        maxSteps: 5,
        threadId: `test-prompt-steps-${Date.now()}`,
      })) {
        if (event.type === "todos-changed") {
          todosUpdated = true;
        }
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should work with all options
      assert.notStrictEqual(doneEvent, null);
      assertContainsMessage(doneEvent.messages, { role: "user", content: "Create a todo item" });
    }, 30000);
  });

  describe("Priority Logic", () => {
    testWithApiKey("messages takes precedence over prompt when both provided", async () => {
      // Given: Both prompt and messages provided
      const prompt = "This should be ignored";
      const messages: ModelMessage[] = [
        { role: "user", content: "This should be used" }
      ];

      // When: Streaming with both parameters
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        prompt,
        messages,
        threadId: `test-priority-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Messages should take precedence
      assert.notStrictEqual(doneEvent, null);
      assertContainsMessage(doneEvent.messages, { role: "user", content: "This should be used" });
      assertNotContainsMessage(doneEvent.messages, { role: "user", content: "This should be ignored" });
    }, 30000);

    test("prompt is ignored when messages is provided even if empty", { timeout: 30000 }, async () => {
      // Given: Empty messages but prompt has content
      const prompt = "Prompt content";
      const messages: ModelMessage[] = [];

      // When: Streaming with empty messages and prompt
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        prompt,
        messages,
        threadId: `test-empty-messages-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Empty messages should still take precedence
      assert.notStrictEqual(doneEvent, null);
      assert.deepStrictEqual(doneEvent.messages, []);
      assertNotContainsMessage(doneEvent.messages, { role: "user", content: "Prompt content" });
    });
  });

  describe("Checkpoint Integration", () => {
    testWithApiKey("uses checkpoint messages when no prompt or messages provided", async () => {
      // Given: Existing checkpoint with messages
      const threadId = `test-checkpoint-${Date.now()}`;
      const checkpointMessages = [
        { role: "user", content: "Checkpoint message" }
      ];

      // Save checkpoint first
      for await (const event of agent.streamWithEvents({
        messages: checkpointMessages,
        threadId,
      })) {
        // Just consume events to save checkpoint
      }

      // When: Streaming without explicit messages (should use checkpoint)
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        threadId,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should load checkpoint messages
      assert.notStrictEqual(doneEvent, null);
      assert.ok(doneEvent.messages.length > 0);
    });

    testWithApiKey("explicit messages replace checkpoint history", async () => {
      // Given: Existing checkpoint and new explicit messages
      const threadId = `test-replace-${Date.now()}`;

      // Create initial checkpoint
      for await (const event of agent.streamWithEvents({
        messages: [{ role: "user", content: "Old checkpoint message" }],
        threadId,
      })) {
        // Consume events
      }

      // When: Streaming with new explicit messages
      const newMessages: ModelMessage[] = [
        { role: "user", content: "New explicit message" }
      ];

      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        messages: newMessages,
        threadId,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should use explicit messages, not checkpoint
      assert.notStrictEqual(doneEvent, null);
      assertContainsMessage(doneEvent.messages, { role: "user", content: "New explicit message" });
      assertNotContainsMessage(doneEvent.messages, { role: "user", content: "Old checkpoint message" });
    });
  });

  describe("Error Handling", () => {
    test("handles neither prompt nor messages provided", { timeout: 30000 }, async () => {
      // Given: No input parameters provided
      const options: any = {
        threadId: `test-error-${Date.now()}`,
      };

      // When: Attempting to stream without input
      // Then: Should handle gracefully (may error or use checkpoint)
      // Implementation-specific behavior expected
      await assert.doesNotReject(async () => {
        for await (const event of agent.streamWithEvents(options)) {
          // Just consume events
        }
      });
    });

    test("preserves checkpoint when both inputs empty", { timeout: 30000 }, async () => {
      // Given: Checkpoint exists but empty inputs provided
      const threadId = `test-preserve-${Date.now()}`;

      // Create checkpoint
      for await (const event of agent.streamWithEvents({
        messages: [{ role: "user", content: "Original" }],
        threadId,
      })) {
        // Consume events
      }

      // When: Streaming with empty prompt and messages
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        prompt: "",
        messages: [],
        threadId,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should fallback to checkpoint or handle gracefully
      assert.notStrictEqual(doneEvent, null);
    });
  });

  describe("Type Safety", () => {
    testWithApiKey("accepts proper ModelMessage array type", async () => {
      // Given: Properly typed ModelMessage array
      const messages: ModelMessage[] = [
        { role: "user", content: "Typed message" }
      ];

      // When: Streaming with typed messages
      // Then: Should compile and run without type errors
      await assert.doesNotReject(async () => {
        for await (const event of agent.streamWithEvents({
          messages,
          threadId: `test-types-${Date.now()}`,
        })) {
          // Just consume events
        }
      });
    });

    testWithApiKey("handles messages with complex content structures", async () => {
      // Given: Messages with potential complex content (future-proofing)
      const messages: ModelMessage[] = [
        { role: "user", content: "Complex message test" }
      ];

      // When: Processing complex messages
      let doneEvent: any = null;
      for await (const event of agent.streamWithEvents({
        messages,
        threadId: `test-complex-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }

      // Then: Should handle without errors
      assert.notStrictEqual(doneEvent, null);
      assertContainsMessage(doneEvent.messages, { role: "user", content: "Complex message test" });
    }, 30000);
  });
});

// ============================================================================
// Phase 2: Integration & Event Tests
// ============================================================================

describe("Phase 2: Integration & Event Handling", () => {
  let backend: StateBackend;
  let agent: any;

  beforeEach(() => {
    backend = new StateBackend(createMockState());
    agent = createDeepAgent({
      model: anthropic("claude-haiku-4-5-20251001"),
      backend,
      checkpointer: new MemorySaver(),
      tools: {
        todoTool: createMockTool("todo"),
      },
    });
  });

  testWithApiKey("maintains event streaming consistency with messages", async () => {
    // Given: Messages parameter with event tracking
    const messages: ModelMessage[] = [
      { role: "user", content: "Generate todos" }
    ];

    const events: string[] = [];
    let checkpointSaved = false;
    let todosChanged = false;
    let textGenerated = false;

    // When: Streaming and collecting events
    for await (const event of agent.streamWithEvents({
      messages,
      threadId: `test-events-${Date.now()}`,
    })) {
      events.push(event.type);

      if (event.type === "checkpoint-saved") {
        checkpointSaved = true;
      }
      if (event.type === "todos-changed") {
        todosChanged = true;
      }
      if (event.type === "text") {
        textGenerated = true;
      }
    }

    // Then: Should maintain expected event flow
    assert.ok(events.length > 0);
    assert.ok(events.includes("done"));
    assert.strictEqual(textGenerated, true);
  }, 30000);

  testWithApiKey("preserves thread ID consistency with messages", async () => {
    // Given: Specific thread ID
    const threadId = `test-thread-${Date.now()}`;
    const messages: ModelMessage[] = [
      { role: "user", content: "Thread test" }
    ];

    let checkpointThreadId: string | null = null;

    // When: Streaming with thread ID
    for await (const event of agent.streamWithEvents({
      messages,
      threadId,
    })) {
      if (event.type === "checkpoint-saved") {
        checkpointThreadId = event.threadId;
      }
    }

    // Then: Thread ID should be preserved in events
    assert.strictEqual(checkpointThreadId, threadId);
  }, 30000);

  testWithApiKey("handles large conversation contexts efficiently", async () => {
    // Given: Large conversation history
    const messages: ModelMessage[] = [];
    for (let i = 0; i < 10; i++) {
      messages.push({ role: "user", content: `User message ${i}` });
      messages.push({
        role: "assistant",
        content: `Assistant response ${i} with some additional context`
      });
    }
    messages.push({ role: "user", content: "What was our last topic?" });

    // When: Processing large context
    const startTime = Date.now();
    let doneEvent: any = null;

    for await (const event of agent.streamWithEvents({
      messages,
      threadId: `test-large-${Date.now()}`,
    })) {
      if (event.type === "done") {
        doneEvent = event;
      }
    }
    const duration = Date.now() - startTime;

    // Then: Should complete within reasonable time
    assert.ok(duration < 60000); // 60 seconds max
    expect(doneEvent).not.toBeNull();
    // Should include all original messages plus assistant response
    assert.ok(doneEvent.messages.length > messages.length);
  }, 60000);
});

// ============================================================================
// Phase 3: Migration & Deprecation Tests
// ============================================================================

describe("Phase 3: Migration & Deprecation", () => {
  let backend: StateBackend;
  let agent: any;

  beforeEach(() => {
    backend = new StateBackend(createMockState());
    agent = createDeepAgent({
      model: anthropic("claude-haiku-4-5-20251001"),
      backend,
      checkpointer: new MemorySaver(),
      tools: {
        migrationTool: createMockTool("migration"),
      },
    });
  });

  testWithApiKey("maintains backward compatibility for existing prompt usage", async () => {
    // Given: Legacy code using prompt parameter
    const prompt = "Legacy prompt usage";

    // When: Using old API pattern
    let doneEvent: any = null;
    let consoleWarnSpy: { mockRestore: () => void; mock: { calls: any[][] } } | null = null;

    // Mock console.warn to capture deprecation warning
    if (typeof console !== 'undefined') {
      const originalWarn = console.warn;
      consoleWarnSpy = {
        mockRestore: () => { /* No-op for node */ },
        mock: { calls: [] }
      };
      console.warn = (...args: any[]) => {
        consoleWarnSpy!.mock.calls.push(args);
        if (process.env.NODE_ENV !== 'production') {
          originalWarn(...args);
        }
      };
    }

    try {
      for await (const event of agent.streamWithEvents({
        prompt,
        threadId: `test-legacy-${Date.now()}`,
      })) {
        if (event.type === "done") {
          doneEvent = event;
        }
      }
    } finally {
      if (consoleWarnSpy) {
        consoleWarnSpy.mockRestore();
      }
    }

    // Then: Should work exactly as before
    expect(doneEvent).not.toBeNull();
    expect(doneEvent.messages).toContainEqual(
      { role: "user", content: "Legacy prompt usage" }
    );
  }, 30000);

  testWithApiKey("enables smooth migration from prompt to messages", async () => {
    // Given: Equivalent prompt and messages
    const prompt = "Migration test";
    const messages: ModelMessage[] = [
      { role: "user", content: "Migration test" }
    ];

    let promptResult: any = null;
    let messagesResult: any = null;

    // When: Using both patterns
    for await (const event of agent.streamWithEvents({
      prompt,
      threadId: `test-prompt-migration-${Date.now()}`,
    })) {
      if (event.type === "done") {
        promptResult = event;
      }
    }

    for await (const event of agent.streamWithEvents({
      messages,
      threadId: `test-messages-migration-${Date.now()}`,
    })) {
      if (event.type === "done") {
        messagesResult = event;
      }
    }

    // Then: Should produce equivalent results
    expect(promptResult).not.toBeNull();
    expect(messagesResult).not.toBeNull();

    // Both should contain the same user message
    expect(promptResult.messages).toContainEqual(
      { role: "user", content: "Migration test" }
    );
    expect(messagesResult.messages).toContainEqual(
      { role: "user", content: "Migration test" }
    );
  }, 45000);

  testWithApiKey("supports gradual migration with mixed usage", async () => {
    // Given: Different migration scenarios
    const scenarios = [
      { prompt: "Scenario 1: prompt only" },
      { messages: [{ role: "user", content: "Scenario 2: messages only" }] },
      {
        prompt: "Scenario 3: ignored",
        messages: [{ role: "user", content: "Scenario 3: used" }]
      }
    ];

    const results: any[] = [];

    // When: Testing all scenarios
    for (let i = 0; i < scenarios.length; i++) {
      const scenario = scenarios[i];

      for await (const event of agent.streamWithEvents({
        ...scenario,
        threadId: `test-migration-${i}-${Date.now()}`,
      })) {
        if (event.type === "done") {
          results[i] = event;
        }
      }
    }

    // Then: All scenarios should work
    assert.strictEqual(results.length, 3);
    results.forEach((result, index) => {
      expect(result).not.toBeNull();
      assert.notStrictEqual(result.messages, undefined);
    });

    // Verify priority logic in mixed scenario
    expect(results[2].messages).toContainEqual(
      { role: "user", content: "Scenario 3: used" }
    );
    expect(results[2].messages).not.toContainEqual(
      { role: "user", content: "Scenario 3: ignored" }
    );
  }, 45000);
});