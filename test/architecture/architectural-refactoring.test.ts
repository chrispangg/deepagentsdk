/**
 * BDD Tests: Architectural Refactoring
 *
 * Generated by: /3_define_test_cases
 * Last updated: 2025-12-21
 * Test coverage: Type system modularisation, error handling standardisation, and function decomposition
 */

import { test, expect, describe, beforeEach, afterEach } from "bun:test";
import { createDeepAgent } from "../../src/agent.ts";
import { StateBackend } from "../../src/backends/state.ts";
import { FilesystemBackend } from "../../src/backends/filesystem.ts";
import { createAnthropic } from '@ai-sdk/anthropic';
import type {
  DeepAgentState,
  CreateDeepAgentParams,
  WriteResult,
  EditResult,
  BackendProtocol,
  SubAgent,
  TodoItem,
  DeepAgentEvent
} from "../../src/types.ts";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as os from "node:os";

// Skip integration tests without API key
const hasApiKey = !!process.env.ANTHROPIC_API_KEY;

// ============================================================================
// Test Helpers and Factories (Used 3+ times across tests)
// ============================================================================

/** Creates a test agent state with minimal setup - used 15+ times */
function createTestState(): DeepAgentState {
  return {
    files: {},
    todos: [],
  };
}

/** Creates a test backend with predefined state - used 12+ times */
function createTestBackend(state?: DeepAgentState): StateBackend {
  return new StateBackend(state || createTestState());
}

/** Creates a test agent with defaults - used 10+ times */
function createTestAgent(overrides?: Partial<CreateDeepAgentParams>) {
  return createDeepAgent({
    model: createAnthropic({
      baseURL: 'https://api.anthropic.com/v1',
    })(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
    backend: createTestBackend(),
    ...overrides,
  });
}

/** Creates event collector for testing event streams - used 6+ times */
function createEventCollector() {
  const events: DeepAgentEvent[] = [];
  const onEvent = (event: DeepAgentEvent) => events.push(event);
  return { events, onEvent };
}

/** Creates a temporary directory for filesystem tests - used 4+ times */
async function createTempDir(): Promise<string> {
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "arch-test-"));
  return tempDir;
}

/** Cleans up temporary directory - used 4+ times */
async function cleanupTempDir(tempDir: string): Promise<void> {
  await fs.rm(tempDir, { recursive: true, force: true });
}

// ============================================================================
// Phase 1: Type System Modularisation
// ============================================================================

describe("Phase 1: Type System Modularisation", () => {
  let tempDir: string;

  beforeEach(async () => {
    tempDir = await createTempDir();
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe("Core Types Module", () => {
    test("should export all core agent configuration types", () => {
      // Given: Import from types (should work after modularisation)

      // When: Creating typed objects
      const config: CreateDeepAgentParams = {
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        backend: createTestBackend(),
      };

      const state: DeepAgentState = createTestState();

      const todo: TodoItem = {
        id: "test-1",
        content: "Test todo",
        status: "pending",
      };

      // Then: Types should be properly defined
      expect(config.model).toBeDefined();
      expect(config.backend).toBeDefined();
      expect(state.files).toEqual({});
      expect(state.todos).toEqual([]);
      expect(todo.id).toBe("test-1");
      expect(todo.status).toBe("pending");
    });

    test("should maintain type safety for complex nested configurations", () => {
      // Given: Complex agent configuration
      const complexConfig: CreateDeepAgentParams = {
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        backend: createTestBackend(),
        subagents: [{
          name: "test-subagent",
          description: "Test subagent for codebase analysis",
          systemPrompt: "You are a codebase analysis specialist",
          tools: { read_file: {} as any, glob: {} as any }, // Simplified for test
        }],
      };

      // When: Creating agent with complex config
      const agent = createDeepAgent(complexConfig);

      // Then: Agent should be created successfully with all properties
      expect(agent).toBeDefined();
      expect(complexConfig.subagents).toBeDefined();
      expect(complexConfig.subagents?.length).toBe(1);
      expect(complexConfig.subagents?.[0]?.name).toBe("test-subagent");
    });
  });

  describe("Backend Types Module", () => {
    test("should export all backend protocol interfaces", async () => {
      // Given: Multiple backend types
      const stateBackend: BackendProtocol = new StateBackend(createTestState());
      const fsBackend: BackendProtocol = new FilesystemBackend({ rootDir: tempDir });

      // When: Testing backend compliance
      const testWrite = async (backend: BackendProtocol): Promise<WriteResult> => {
        return await backend.write("test.txt", "test content");
      };

      // Then: All backends should implement the protocol correctly
      const stateResult = await testWrite(stateBackend);
      const fsResult = await testWrite(fsBackend);

      expect(stateResult).toBeDefined();
      expect(fsResult).toBeDefined();
      expect(typeof stateResult.path).toBe("string");
      expect(typeof fsResult.path).toBe("string");
    });

    test("should maintain compatibility between different backend implementations", async () => {
      // Given: Multiple backend implementations
      const backends: BackendProtocol[] = [
        new StateBackend(createTestState()),
        new FilesystemBackend({ rootDir: tempDir }),
      ];

      // When: Performing operations on all backends
      for (const backend of backends) {
        // Write operation
        const writeResult = await backend.write("test.txt", "test content");
        expect(writeResult.path).toBe("test.txt");

        // Read operation
        const readResult = await backend.read("test.txt");
        // Both backends format read results with line numbers for better agent UX
        expect(readResult).toContain("test content");
        expect(readResult).toMatch(/\d+\s+test content/);
      }

      // Then: All operations should work consistently across implementations
      expect(backends).toHaveLength(2);
    });
  });

  describe("Events Types Module", () => {
    test("should export all event types for comprehensive coverage", () => {
      // Given: Event collector
      const { events, onEvent } = createEventCollector();

      // When: Collecting different event types
      const testEvents: DeepAgentEvent[] = [
        { type: "text", text: "Test text" },
        { type: "tool-call", toolCallId: "test", toolName: "test_tool", args: {} },
        { type: "tool-result", toolCallId: "test", toolName: "test_tool", result: "success" },
        { type: "error", error: new Error("Test error") },
        { type: "done", state: createTestState() },
      ];

      testEvents.forEach(onEvent);

      // Then: All event types should be properly typed and collected
      expect(events).toHaveLength(5);
      expect(events[0]?.type).toBe("text");
      expect(events[1]?.type).toBe("tool-call");
      expect(events[2]?.type).toBe("tool-result");
      expect(events[3]?.type).toBe("error");
      expect(events[4]?.type).toBe("done");
    });

    test("should maintain event type safety with discriminated unions", () => {
      // Given: Mixed events
      const events: DeepAgentEvent[] = [
        { type: "text", text: "Test text" },
        { type: "tool-call", toolCallId: "test", toolName: "test_tool", args: {} },
        { type: "error", error: new Error("Test error") },
      ];

      // When: Processing events with type guards
      const textEvents = events.filter(e => e.type === "text");
      const toolEvents = events.filter(e => e.type === "tool-call");
      const errorEvents = events.filter(e => e.type === "error");

      // Then: TypeScript should narrow types correctly
      expect(textEvents).toHaveLength(1);
      expect(textEvents[0]).toHaveProperty("text");

      expect(toolEvents).toHaveLength(1);
      expect(toolEvents[0]).toHaveProperty("toolCallId");

      expect(errorEvents).toHaveLength(1);
      expect(errorEvents[0]).toHaveProperty("error");
    });
  });

  describe("Subagent Types Module", () => {
    test("should export subagent infrastructure types", () => {
      // Given: Subagent configuration
      const subagent: SubAgent = {
        name: "test-subagent",
        description: "Test subagent for analysis",
        systemPrompt: "You are a test subagent",
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        tools: { read_file: {} as any, glob: {} as any, grep: {} as any },
      };

      // When: Creating agent with subagents
      const agent = createDeepAgent({
        model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
        backend: createTestBackend(),
        subagents: [subagent],
      });

      // Then: Subagent types should be properly enforced
      expect(agent).toBeDefined();
      expect(subagent.name).toBe("test-subagent");
      expect(subagent.description).toBe("Test subagent for analysis");
      expect(subagent.systemPrompt).toBe("You are a test subagent");
      expect(subagent.tools).toHaveProperty("read_file");
    });

    test("should validate subagent tool configurations", () => {
      // Given: Different subagent configurations
      const subagents: SubAgent[] = [
        {
          name: "analyzer",
          description: "Codebase analyzer",
          systemPrompt: "You analyze codebases",
          model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
          tools: { read_file: {} as any, glob: {} as any, grep: {} as any },
        },
        {
          name: "researcher",
          description: "Web researcher",
          systemPrompt: "You research topics using web tools",
          model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
          tools: { web_search: {} as any, web_fetch: {} as any },
        },
      ];

      // When: Creating agents with different subagent configs
      const agents = subagents.map(subagent =>
        createDeepAgent({
          model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
          backend: createTestBackend(),
          subagents: [subagent],
        })
      );

      // Then: All configurations should be valid
      expect(agents).toHaveLength(2);
      expect(agents[0]).toBeDefined();
      expect(agents[1]).toBeDefined();
    });
  });

  describe("Backward Compatibility", () => {
    test("should maintain all existing exports from types.ts", () => {
      // Given: Import from main types file (should re-export everything)

      // When: Using types as before refactoring
      const agent = createTestAgent();

      // Then: All types should be available without import path changes
      expect(agent).toBeDefined();
      expect(agent.generate).toBeDefined();
      expect(agent.stream).toBeDefined();
    });

    test("should maintain type access after modularisation", async () => {
      // Given: Direct imports from types
      const types = await import("../../src/types.ts");

      // When: Creating typed objects
      const state = createTestState() as any;

      // Then: Types should work regardless of import path
      expect(state).toBeDefined();
      expect(state.files).toBeDefined();
      expect(state.todos).toBeDefined();
    });
  });
});

// ============================================================================
// Phase 2: Error Handling Standardisation
// ============================================================================

describe("Phase 2: Error Handling Standardisation", () => {
  let tempDir: string;
  let stateBackend: StateBackend;
  let fsBackend: FilesystemBackend;

  beforeEach(async () => {
    tempDir = await createTempDir();
    stateBackend = createTestBackend();
    fsBackend = new FilesystemBackend({ rootDir: tempDir });
  });

  afterEach(async () => {
    await cleanupTempDir(tempDir);
  });

  describe("WriteResult Interface", () => {
    test("should maintain backward compatibility with current WriteResult structure", async () => {
      // Given: Multiple backend implementations
      const backends = [stateBackend, fsBackend];

      for (const backend of backends) {
        // When: Writing a file
        const result = await backend.write("test.txt", "test content");

        // Then: Result should maintain current structure
        expect(result).toHaveProperty("path");
        if (result.error) {
          expect(typeof result.error).toBe("string");
          expect(result.path).toBeUndefined();
        } else {
          expect(typeof result.path).toBe("string");
          expect(result.error).toBeUndefined();
        }
      }
    });

    test("should return path for successful writes", async () => {
      // Given: Valid file content
      const content = "Test file content";

      // When: Writing to different backends
      const stateResult = await stateBackend.write("success.txt", content);
      const fsResult = await fsBackend.write("success.txt", content);

      // Then: Both should return path without error
      expect(stateResult.path).toBe("success.txt");
      expect(fsResult.path).toBe("success.txt");
      expect(stateResult.error).toBeUndefined();
      expect(fsResult.error).toBeUndefined();
    });

    test("should return error for failed writes", async () => {
      // Given: State backend with existing file
      await stateBackend.write("exists.txt", "original");

      // When: Attempting to write to same file (should fail for state backend)
      const duplicateResult = await stateBackend.write("exists.txt", "duplicate");

      // Then: Should return error without path
      expect(duplicateResult.error).toBeDefined();
      expect(duplicateResult.error).toContain("already exists");
      expect(duplicateResult.path).toBeUndefined();
    });

    test("should maintain compatibility with existing error checking patterns", async () => {
      // Given: Backend that might fail
      const backend = stateBackend;
      await backend.write("existing.txt", "content");

      // When: Using current error checking pattern
      const result = await backend.write("existing.txt", "new content");

      // Then: Current pattern should work (will be enhanced with success field later)
      if (result.error) {
        expect(result.error).toContain("already exists");
        expect(result.path).toBeUndefined();
      } else {
        // Should not reach here for this test case
        expect(true).toBe(false);
      }
    });
  });

  describe("EditResult Interface", () => {
    test("should maintain backward compatibility with current EditResult structure", async () => {
      // Given: Files to edit
      await stateBackend.write("edit-test.txt", "original content");
      await fsBackend.write("edit-test.txt", "original content");

      // When: Editing files
      const stateResult = await stateBackend.edit("edit-test.txt", "original", "modified");
      const fsResult = await fsBackend.edit("edit-test.txt", "original", "modified");

      // Then: Results should maintain current structure
      expect(stateResult).toHaveProperty("path");
      expect(fsResult).toHaveProperty("path");
      if (stateResult.error) {
        expect(typeof stateResult.error).toBe("string");
        expect(stateResult.path).toBeUndefined();
      } else {
        expect(typeof stateResult.path).toBe("string");
        expect(stateResult.error).toBeUndefined();
      }
    });

    test("should return path for successful edits", async () => {
      // Given: File with editable content
      await stateBackend.write("editable.txt", "Original content");

      // When: Performing successful edit
      const result = await stateBackend.edit("editable.txt", "Original", "Modified");

      // Then: Should report success with metrics
      expect(result.path).toBe("editable.txt");
      expect(result.occurrences).toBe(1);
      expect(result.error).toBeUndefined();
    });

    test("should return error for failed edits", async () => {
      // Given: File without target text
      await stateBackend.write("no-match.txt", "Different content");

      // When: Attempting edit with non-existent text
      const result = await stateBackend.edit("no-match.txt", "not found", "replacement");

      // Then: Should report failure
      expect(result.error).toBeDefined();
      expect(result.error).toContain("not found");
      expect(result.path).toBeUndefined();
      expect(result.occurrences).toBeUndefined();
    });
  });

  describe("Consistent Error Patterns", () => {
    test("should handle file not found consistently", async () => {
      // Given: Non-existent file
      const nonExistentFile = "does-not-exist.txt";

      // When: Attempting operations on non-existent file
      const readResult = await stateBackend.read(nonExistentFile);
      const editResult = await stateBackend.edit(nonExistentFile, "test", "test");

      // Then: Both should return error strings
      expect(typeof readResult).toBe("string");
      expect(readResult).toContain("not found");
      expect(editResult.error).toBeDefined();
      expect(editResult.error).toContain("not found");
    });

    test("should handle invalid operations gracefully", async () => {
      // Given: Empty file path
      const invalidPath = "";

      // When: Attempting operations with invalid path
      const writeResult = await stateBackend.write(invalidPath, "content");

      // Then: Should return structured error
      expect(writeResult.error).toBeDefined();
      expect(writeResult.path).toBeUndefined();
    });
  });
});

// ============================================================================
// Phase 3: Function Decomposition
// ============================================================================

describe("Phase 3: Function Decomposition", () => {
  test.skipIf(!hasApiKey)("should break down streamWithEvents into focused methods", async () => {
    // Given: Agent instance
    const agent = createTestAgent();
    const events: DeepAgentEvent[] = [];

    // When: Streaming with events (tests refactored streamWithEvents implementation)
    for await (const event of agent.streamWithEvents({ prompt: "Simple test" })) {
      events.push(event);
      if (event.type === "done") break;
    }

    // Then: Should receive expected event sequence
    expect(events.length).toBeGreaterThan(0);
    expect(events.some(e => e.type === "done")).toBe(true);
  });

  test("should decompose createTools into logical groupings", () => {
    // Given: Agent with multiple tool categories
    const agent = createDeepAgent({
      model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
      backend: createTestBackend(),
    });

    // When: Accessing agent's tools (will use refactored createTools)
    // Note: This tests the interface, implementation details tested separately

    // Then: Agent should be created successfully
    expect(agent).toBeDefined();
  });

  test("should maintain identical behavior after decomposition", async () => {
    // Given: Multiple agents with same configuration
    const config = {
      model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
      backend: createTestBackend(),
    };

    // When: Creating agents with same config
    const agent1 = createDeepAgent(config);
    const agent2 = createDeepAgent(config);

    // Then: Should have identical capabilities
    expect(agent1.generate).toBeDefined();
    expect(agent2.generate).toBeDefined();
    expect(agent1.stream).toBeDefined();
    expect(agent2.stream).toBeDefined();
  });
});

// ============================================================================
// Integration Tests (Real API)
// ============================================================================

describe("Integration Tests", () => {
  let agent: ReturnType<typeof createDeepAgent>;

  beforeEach(() => {
    agent = createTestAgent();
  });

  test.skipIf(!hasApiKey)(
    "end-to-end test with all architectural improvements",
    async () => {
      // Given: Real agent with modularized types
      const events: DeepAgentEvent[] = [];

      // When: Performing complex operation with event streaming
      for await (const event of agent.streamWithEvents({ prompt: "Write a hello world function in JavaScript" })) {
        events.push(event);
        if (event.type === "done") break;
      }

      // Then: Should work seamlessly with new architecture
      const doneEvent = events.find(e => e.type === "done");
      expect(doneEvent).toBeDefined();
      if (doneEvent && doneEvent.type === "done" && doneEvent.text) {
        expect(doneEvent.text.length).toBeGreaterThan(0);
      }
      expect(events.length).toBeGreaterThan(0);
    },
    { timeout: 30000 }
  );

  test.skipIf(!hasApiKey)(
    "error handling works in real environment",
    async () => {
      // Given: Agent for integration testing
      const agent = createTestAgent();

      // When: Making request that might trigger various paths
      const result = await agent.generate({
        prompt: "List files in current directory"
      });

      // Then: Should handle errors gracefully
      expect(result.text).toBeDefined();
      // Should not crash or hang
    },
    { timeout: 30000 }
  );
});

// ============================================================================
// Performance and Compatibility Tests
// ============================================================================

describe("Performance and Compatibility", () => {
  test("should not introduce performance regressions", () => {
    // Given: Large number of type imports
    const start = performance.now();

    // When: Importing all modularized types
    import("../../src/types.ts");

    const end = performance.now();
    const importTime = end - start;

    // Then: Import time should be reasonable (< 100ms)
    expect(importTime).toBeLessThan(100);
  });

  test("should maintain type checking performance", () => {
    // Given: Complex type usage
    const complexConfig: CreateDeepAgentParams = {
      model: createAnthropic()(process.env.ANTHROPIC_MODEL || "claude-haiku-4-5-20251001"),
      backend: createTestBackend(),
      subagents: Array(10).fill(null).map((_, i) => ({
        name: `agent-${i}`,
        description: `Agent ${i} for testing`,
        systemPrompt: `You are agent ${i}`,
        tools: { read_file: {} as any, write_file: {} as any },
      })),
    };

    // When: Creating agent with complex configuration
    const agent = createDeepAgent(complexConfig);

    // Then: Should be created without type errors
    expect(agent).toBeDefined();
    expect(complexConfig.subagents).toHaveLength(10);
  });

  test("should support gradual migration", () => {
    // Given: Mixed import patterns
    import("../../src/types.ts");

    // When: Using types from different import styles
    const state1: DeepAgentState = createTestState();
    const state2: DeepAgentState = createTestState();

    // Then: Should work interchangeably
    expect(state1).toEqual(state2);
    expect(state1.files).toEqual(state2.files);
    expect(state1.todos).toEqual(state2.todos);
  });
});