/**
 * BDD Tests: Structured Output Support
 *
 * Comprehensive test suite for adding structured output parsing to DeepAgent
 * and subagents. Tests cover both main agent output parsing and subagent
 * structured output delegation.
 *
 * Generated by: /3_define_test_cases
 * Last updated: 2025-12-19
 * Test coverage: Phase 1 (main agent) + Phase 1.5 (subagent) implementation
 */

import { test, describe, beforeEach } from "node:test";
import { createDeepAgent } from "@/agent.ts";
import { StateBackend } from "@/backends/state.ts";
import type { DeepAgentState, CreateDeepAgentParams, DoneEvent, SubAgent } from "@/types.ts";
import { tool } from "ai";
import { z } from "zod";
import { createAnthropic } from '@ai-sdk/anthropic';
import assert from "node:assert/strict";
import { expect } from "expect";

type TestCallback = () => void | Promise<void>;
type TestOptions = { timeout?: number } & Record<string, unknown>;

const skipIf = (condition: boolean) => {
  const runner = condition ? test.skip : test;
  return (name: string, fn: TestCallback, options?: TestOptions) => {
    if (options) {
      runner(name, options, fn);
      return;
    }
    runner(name, fn);
  };
};

const anthropic = createAnthropic({
  baseURL: 'https://api.anthropic.com/v1',
});

// ============================================================================
// Test Helpers
// ============================================================================

/**
 * Create a mock DeepAgentState for testing.
 * Used 10+ times across all tests.
 */
function createMockState(): DeepAgentState {
  return {
    files: {},
    todos: [],
  };
}

/**
 * Create a simple calculation tool for testing.
 * Returns structured data (numbers).
 */
function createCalculationTool() {
  return tool({
    description: "Performs basic math operations",
    inputSchema: z.object({
      operation: z.enum(["add", "subtract", "multiply"]),
      a: z.number(),
      b: z.number(),
    }),
    execute: async ({ operation, a, b }) => {
      switch (operation) {
        case "add":
          return String(a + b);
        case "subtract":
          return String(a - b);
        case "multiply":
          return String(a * b);
      }
    },
  });
}

/**
 * Create a sentiment analysis tool for testing.
 * Returns structured sentiment data.
 */
function createSentimentTool() {
  return tool({
    description: "Analyzes sentiment of text",
    inputSchema: z.object({
      text: z.string(),
    }),
    execute: async ({ text }) => {
      // Mock sentiment analysis
      const hasPositive = text.match(/good|great|excellent|love/i);
      const hasNegative = text.match(/bad|terrible|hate|awful/i);

      const sentiment = hasPositive ? "positive" : hasNegative ? "negative" : "neutral";
      const score = hasPositive ? 0.8 : hasNegative ? 0.2 : 0.5;

      return JSON.stringify({ sentiment, score, length: text.length });
    },
  });
}

/**
 * Create a test output schema for validation.
 * Used 5+ times for schema specification.
 */
function createTestOutputSchema() {
  return z.object({
    sentiment: z.enum(["positive", "negative", "neutral"]),
    score: z.number().min(0).max(1),
    summary: z.string(),
  });
}

/**
 * Create a calculation result schema.
 * Used for mathematical operation validation.
 */
function createCalculationSchema() {
  return z.object({
    operation: z.string(),
    result: z.number(),
    explanation: z.string(),
  });
}

/**
 * Mock event collector for testing event emissions.
 * Used 3+ times for event stream testing.
 */
function createEventCollector() {
  const events: any[] = [];
  const onEvent = (event: any) => events.push(event);
  return { events, onEvent };
}

// ============================================================================
// Phase 1: Core Structured Output Implementation
// ============================================================================

describe("Phase 1: Core Structured Output", () => {
  let backend: StateBackend;

  beforeEach(() => {
    backend = new StateBackend({ todos: [], files: {} });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.1: Type Definition Tests
  // ──────────────────────────────────────────────────────────────────────────

  describe("CreateDeepAgentParams type - output field", () => {
    test("accepts optional output schema configuration", async () => {
      // Given: A valid output schema
      const outputSchema = createTestOutputSchema();

      // When: Creating an agent with output config (type checking)
      const params: CreateDeepAgentParams = {
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: {
          schema: outputSchema,
          description: "Sentiment analysis output",
        },
      };

      // Then: Type definition should accept the output field
      assert.notStrictEqual(params.output, undefined);
      assert.strictEqual(params.output?.schema, outputSchema);
      assert.strictEqual(params.output?.description, "Sentiment analysis output");
    });

    test("output field is optional and can be undefined", () => {
      // Given: No output config provided
      // When: Creating agent without output field (type checking)
      const params: CreateDeepAgentParams = {
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        // output intentionally omitted
      };

      // Then: Should be valid without output field
      assert.strictEqual(params.output, undefined);
    });

    test("output schema can be any Zod type", () => {
      // Given: Various Zod schemas
      const numberSchema = z.number();
      const stringSchema = z.string();
      const objectSchema = z.object({ value: z.string() });
      const arraySchema = z.array(z.object({ id: z.number() }));

      // When: Using each schema as output
      const params1: CreateDeepAgentParams = {
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: { schema: numberSchema },
      };

      // Then: All should be accepted
      assert.strictEqual(params1.output?.schema, numberSchema);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.2: Agent Creation with Output Config
  // ──────────────────────────────────────────────────────────────────────────

  describe("createDeepAgent() with structured output", () => {
    test("creates agent successfully with output schema", async () => {
      // Given: Valid agent configuration with output schema
      const outputSchema = createTestOutputSchema();

      // When: Creating agent with structured output config
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        tools: { sentiment: createSentimentTool() },
        output: {
          schema: outputSchema,
          description: "Sentiment analysis with score",
        },
      });

      // Then: Agent should be created and store output config
      assert.notStrictEqual(agent, undefined);
      expect((agent as any).outputConfig).toBeDefined();
      expect((agent as any).outputConfig.schema).toBe(outputSchema);
    });

    test("creates agent without output schema (backwards compatible)", async () => {
      // Given: No output config provided
      // When: Creating agent without structured output
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        tools: { sentiment: createSentimentTool() },
      });

      // Then: Agent should work normally without output config
      assert.notStrictEqual(agent, undefined);
      expect((agent as any).outputConfig).toBeUndefined();
    });

    test("stores output configuration on agent instance", () => {
      // Given: Output schema with description
      const outputSchema = createCalculationSchema();
      const description = "Calculation with explanation";

      // When: Creating agent with output config
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: {
          schema: outputSchema,
          description,
        },
      });

      // Then: Output config should be accessible on agent instance
      expect((agent as any).outputConfig).toBeDefined();
      expect((agent as any).outputConfig.schema).toBe(outputSchema);
      expect((agent as any).outputConfig.description).toBe(description);
    });

    test("validates output schema is Zod type", () => {
      // Given: Invalid output config (not a Zod schema)
      const invalidConfig = { schema: { invalid: "object" } };

      // When/Then: Should not create agent with non-Zod schema
      // (This would be caught by TypeScript, but runtime validation could be added)
      assert.notStrictEqual(invalidConfig, undefined);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.3: ToolLoopAgent Configuration
  // ──────────────────────────────────────────────────────────────────────────

  describe("ToolLoopAgent receives output configuration", () => {
    test("passes output schema to ToolLoopAgent constructor", async () => {
      // Given: Agent with output schema
      const outputSchema = createTestOutputSchema();
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: {
          schema: outputSchema,
          description: "Test output",
        },
      });

      // When: Accessing internal ToolLoopAgent configuration
      // (This would be verified during implementation)

      // Then: Output should be passed to ToolLoopAgent
      // The agent's createAgent() method should include:
      // ...(this.outputConfig ? { output: this.outputConfig } : {})
      expect((agent as any).outputConfig).toBeDefined();
    });

    test("omits output field from ToolLoopAgent when undefined", () => {
      // Given: Agent created without output config
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
      });

      // When: ToolLoopAgent is created
      // Then: Should not include output field (backwards compatible)
      expect((agent as any).outputConfig).toBeUndefined();
    });

    test("includes optional description in output config", () => {
      // Given: Output config with description
      const description = "Analyze sentiment and provide score";

      // When: Creating agent with description
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: {
          schema: createTestOutputSchema(),
          description,
        },
      });

      // Then: Description should be included in output config
      expect((agent as any).outputConfig.description).toBe(description);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.4: Result Enhancement with Structured Output
  // ──────────────────────────────────────────────────────────────────────────

  describe("Result object enhancement with structured output", () => {
    test("preserves original result properties when output is returned", () => {
      // Given: Agent with output schema
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: { schema: z.object({ value: z.string() }) },
      });

      // When: Result is returned from agent
      // (In real execution, ToolLoopAgent returns { text, output, ... })

      // Then: Original properties should be preserved
      // The Object.defineProperty pattern should maintain compatibility
      // assert.notStrictEqual(result.text, undefined);
      // assert.notStrictEqual(result.output, undefined);
      assert.notStrictEqual(agent, undefined);
    });

    test("adds structured output property to result using Object.defineProperty", () => {
      // Given: Result from ToolLoopAgent with output field
      const mockResult = {
        text: "Sentiment analysis complete",
        output: { sentiment: "positive", score: 0.85, summary: "Very positive" },
        finishReason: "end-turn" as const,
      };

      // When: Using Object.defineProperty pattern (as in existing code)
      Object.defineProperty(mockResult, "structured", {
        value: mockResult.output,
        enumerable: true,
        writable: false,
      });

      // Then: Structured output should be accessible
      expect((mockResult as any).structured).toBeDefined();
      expect((mockResult as any).structured.sentiment).toBe("positive");
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5: DoneEvent Type Enhancement
  // ──────────────────────────────────────────────────────────────────────────

  describe("DoneEvent type - output field", () => {
    test("DoneEvent includes optional output field when structured output is used", () => {
      // Given: Output configuration
      // When: Agent completes with structured output
      // Then: DoneEvent should include output field

      // Example DoneEvent structure:
      const doneEvent: DoneEvent = {
        type: "done",
        state: { todos: [], files: {} },
        output: { sentiment: "positive", score: 0.85, summary: "Very positive" },
      };

      assert.strictEqual(doneEvent.type, "done");
      assert.notStrictEqual(doneEvent.output, undefined);
    });

    test("DoneEvent output field is optional and backwards compatible", () => {
      // Given: No structured output configured
      // When: Agent completes without output
      // Then: DoneEvent should work without output field

      const doneEvent: DoneEvent = {
        type: "done",
        state: { todos: [], files: {} },
        // output field omitted
      };

      assert.strictEqual(doneEvent.type, "done");
      assert.strictEqual(doneEvent.output, undefined);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.6: Edge Cases and Error Handling
  // ──────────────────────────────────────────────────────────────────────────

  describe("Edge cases and validation", () => {
    test("handles empty object schema", () => {
      // Given: Schema with no required fields
      const emptySchema = z.object({});

      // When: Creating agent
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: { schema: emptySchema },
      });

      // Then: Should accept and configure the agent
      assert.notStrictEqual(agent, undefined);
      expect((agent as any).outputConfig?.schema).toBe(emptySchema);
    });

    test("handles complex nested schema", () => {
      // Given: Complex nested Zod schema
      const complexSchema = z.object({
        analysis: z.object({
          sentiment: z.enum(["positive", "negative", "neutral"]),
          scores: z.object({
            overall: z.number(),
            confidence: z.number(),
          }),
          tags: z.array(z.string()),
        }),
      });

      // When: Using complex schema
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: { schema: complexSchema },
      });

      // Then: Complex schema should be accepted
      expect((agent as any).outputConfig?.schema).toBe(complexSchema);
    });

    test("preserves schema definition when creating multiple agents", () => {
      // Given: Same output schema used for multiple agents
      const schema = createTestOutputSchema();

      // When: Creating two agents with same schema
      const agent1 = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        output: { schema },
      });

      const agent2 = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend: new StateBackend({ todos: [], files: {} }),
        output: { schema },
      });

      // Then: Both agents should reference same schema
      expect((agent1 as any).outputConfig?.schema).toBe(schema);
      expect((agent2 as any).outputConfig?.schema).toBe(schema);
    });
  });
});

// ============================================================================
// Phase 1.5: Subagent Structured Output
// ============================================================================

describe("Phase 1.5: Subagent Structured Output", () => {
  let backend: StateBackend;

  beforeEach(() => {
    backend = new StateBackend({ todos: [], files: {} });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5.1: SubAgent Type Enhancement
  // ──────────────────────────────────────────────────────────────────────────

  describe("SubAgent interface - output field", () => {
    test("SubAgent interface includes optional output field", () => {
      // Given: SubAgent configuration with output
      const subagentConfig: SubAgent = {
        name: "sentiment-analyzer",
        description: "Analyzes sentiment of text",
        model: anthropic("claude-haiku-4-5-20251001"),
        systemPrompt: "You are a sentiment analyzer",
        tools: { sentiment: createSentimentTool() },
        output: {
          schema: createTestOutputSchema(),
          description: "Structured sentiment output",
        },
      };

      // When: Validating SubAgent type
      // Then: output field should be optional but accepted
      assert.notStrictEqual(subagentConfig.output, undefined);
      assert.notStrictEqual(subagentConfig.output?.schema, undefined);
    });

    test("SubAgent output field is optional (backwards compatible)", () => {
      // Given: SubAgent without output config
      const subagentConfig: SubAgent = {
        name: "sentiment-analyzer",
        description: "Analyzes sentiment of text",
        model: anthropic("claude-haiku-4-5-20251001"),
        systemPrompt: "You are a sentiment analyzer",
        tools: { sentiment: createSentimentTool() },
        // output intentionally omitted
      };

      // When: Creating subagent without output
      // Then: Should work normally
      assert.strictEqual(subagentConfig.output, undefined);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5.2: Subagent Registry Update
  // ──────────────────────────────────────────────────────────────────────────

  describe("Subagent registry with structured output", () => {
    test("registry stores output configuration for each subagent", () => {
      // Given: Subagent with output config
      const outputSchema = createTestOutputSchema();

      // When: Storing subagent in registry
      const registry: Record<string, SubAgent> = {
        sentiment_analyzer: {
          name: "sentiment-analyzer",
          description: "Analyzes sentiment",
          model: anthropic("claude-haiku-4-5-20251001"),
          systemPrompt: "Analyze sentiment",
          tools: { sentiment: createSentimentTool() },
          output: {
            schema: outputSchema,
            description: "Sentiment analysis output",
          },
        },
      };

      // Then: Registry should store output config
      const sentimentAnalyzer = registry["sentiment_analyzer"];
      assert.notStrictEqual(sentimentAnalyzer?.output, undefined);
      assert.strictEqual(sentimentAnalyzer?.output?.schema, outputSchema);
    });

    test("registry handles subagents with and without output configs", () => {
      // Given: Registry with mixed subagent configurations
      const registry: Record<string, SubAgent> = {
        with_output: {
          name: "analyzer",
          description: "Analyzer agent",
          model: anthropic("claude-haiku-4-5-20251001"),
          systemPrompt: "Analyzer",
          tools: { sentiment: createSentimentTool() },
          output: { schema: createTestOutputSchema() },
        },
        without_output: {
          name: "helper",
          description: "Helper agent",
          model: anthropic("claude-haiku-4-5-20251001"),
          systemPrompt: "Helper",
          tools: { calc: createCalculationTool() },
        },
      };

      // When: Accessing registry
      // Then: Both configurations should be valid
      const withOutput = registry["with_output"];
      const withoutOutput = registry["without_output"];
      assert.notStrictEqual(withOutput?.output, undefined);
      assert.strictEqual(withoutOutput?.output, undefined);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5.3: Subagent ToolLoopAgent Configuration
  // ──────────────────────────────────────────────────────────────────────────

  describe("Subagent ToolLoopAgent receives output configuration", () => {
    test("output config is passed to subagent ToolLoopAgent constructor", () => {
      // Given: Subagent configuration with output schema
      const outputSchema = createTestOutputSchema();
      const subagentConfig: SubAgent = {
        name: "sentiment-analyzer",
        description: "Analyzes sentiment",
        model: anthropic("claude-haiku-4-5-20251001"),
        systemPrompt: "Analyze sentiment",
        tools: { sentiment: createSentimentTool() },
        output: {
          schema: outputSchema,
          description: "Sentiment analysis",
        },
      };

      // When: Creating subagent's ToolLoopAgent
      // (Would use spread operator: ...(subagentConfig.output ? { output: subagentConfig.output } : {}))

      // Then: Output should be included in ToolLoopAgent config
      assert.notStrictEqual(subagentConfig.output, undefined);
    });

    test("subagent ToolLoopAgent omits output when not configured", () => {
      // Given: Subagent without output config
      const subagentConfig: SubAgent = {
        name: "helper",
        description: "Helper agent",
        model: anthropic("claude-haiku-4-5-20251001"),
        systemPrompt: "Helper",
        tools: { calc: createCalculationTool() },
      };

      // When: Creating ToolLoopAgent without output
      // Then: Should not break (backwards compatible)
      assert.strictEqual(subagentConfig.output, undefined);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5.4: Subagent Result Formatting
  // ──────────────────────────────────────────────────────────────────────────

  describe("Subagent result formatting with structured output", () => {
    test("formats structured output as JSON when present", () => {
      // Given: Subagent result with output field
      const result = {
        text: "Sentiment analysis complete",
        output: {
          sentiment: "positive",
          score: 0.85,
          summary: "Very positive feedback",
        },
        finishReason: "end-turn" as const,
      };

      // When: Formatting for parent agent
      const hasOutput = result.output !== undefined;
      let formattedResult = result.text;
      if (hasOutput) {
        formattedResult = `${result.text}\n\n[Structured Output]\n${JSON.stringify(result.output, null, 2)}`;
      }

      // Then: Should include formatted structured output
      assert.ok(formattedResult.includes("Sentiment analysis complete"));
      assert.ok(formattedResult.includes("[Structured Output]"));
      assert.ok(formattedResult.includes('"sentiment": "positive"'));
    });

    test("returns only text when subagent has no output config", () => {
      // Given: Subagent result without output
      const result = {
        text: "Calculation complete: 42",
        finishReason: "end-turn" as const,
      };

      // When: Formatting result
      let formattedResult = result.text;

      // Then: Should return text unchanged
      assert.strictEqual(formattedResult, "Calculation complete: 42");
      assert.ok(!formattedResult.includes("[Structured Output]"));
    });

    test("handles complex nested structured output", () => {
      // Given: Subagent with complex nested output
      const result = {
        text: "Analysis complete",
        output: {
          analysis: {
            sentiment: "positive",
            scores: {
              overall: 0.85,
              confidence: 0.92,
            },
            tags: ["feedback", "customer", "happy"],
          },
        },
        finishReason: "end-turn" as const,
      };

      // When: Formatting complex nested output
      const formatted = `${result.text}\n\n[Structured Output]\n${JSON.stringify(result.output, null, 2)}`;

      // Then: JSON should preserve nested structure
      assert.ok(formatted.includes('"sentiment": "positive"'));
      assert.ok(formatted.includes('"overall": 0.85'));
      assert.ok(formatted.includes('"tags"'));
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5.5: Parent Agent Consumption of Subagent Output
  // ──────────────────────────────────────────────────────────────────────────

  describe("Parent agent receives subagent structured output", () => {
    test("subagent output is included in tool result for parent agent", () => {
      // Given: Parent agent delegating to subagent with output
      // When: Subagent completes with structured output
      const subagentResult = `Initial analysis: positive sentiment\n\n[Structured Output]\n{"sentiment": "positive", "score": 0.85, "summary": "Very positive"}`;

      // Then: Parent agent tool result should include formatted output
      assert.ok(subagentResult.includes("[Structured Output]"));
      assert.ok(subagentResult.includes('"sentiment": "positive"'));
    });

    test("parent agent can parse subagent JSON output", () => {
      // Given: Subagent result with structured output
      const resultText = `Sentiment analysis:\n\n[Structured Output]\n{"sentiment": "positive", "score": 0.85, "summary": "Very positive"}`;

      // When: Parent agent parses the output
      const jsonMatch = resultText.match(/\[Structured Output\]\n([\s\S]*?)$/);
      const parsedOutput = jsonMatch && jsonMatch[1] ? JSON.parse(jsonMatch[1]) as any : null;

      // Then: Should successfully extract and parse JSON
      assert.notStrictEqual(parsedOutput, undefined);
      assert.strictEqual(parsedOutput.sentiment, "positive");
      assert.strictEqual(parsedOutput.score, 0.85);
    });
  });

  // ──────────────────────────────────────────────────────────────────────────
  // 1.5.6: Subagent Output Edge Cases
  // ──────────────────────────────────────────────────────────────────────────

  describe("Subagent output edge cases", () => {
    test("handles subagent with no tools but with output config", () => {
      // Given: Subagent configured with output but no tools
      const subagentConfig: SubAgent = {
        name: "summarizer",
        description: "Generates summaries",
        model: anthropic("claude-haiku-4-5-20251001"),
        systemPrompt: "Generate a summary",
        tools: {},
        output: { schema: z.object({ summary: z.string() }) },
      };

      // When: Creating subagent
      // Then: Should be valid configuration
      assert.notStrictEqual(subagentConfig.output, undefined);
    });

    test("handles output schema validation type mismatch", () => {
      // Given: Subagent returns invalid structured output
      const result = {
        text: "Result",
        output: { invalid: "field" }, // Doesn't match schema
        finishReason: "end-turn" as const,
      };

      // When: ToolLoopAgent parses with schema
      // (ToolLoopAgent's native support handles validation)

      // Then: Validation error would be caught by ToolLoopAgent
      assert.notStrictEqual(result.output, undefined);
    });

    test("maintains output format consistency across multiple subagents", () => {
      // Given: Multiple subagents with different output schemas
      const sentimentOutput = `\n\n[Structured Output]\n{"sentiment": "positive", "score": 0.85}`;
      const calcOutput = `\n\n[Structured Output]\n{"operation": "add", "result": 42}`;

      // When: Formatting outputs from different subagents
      // Then: Both should follow same format pattern
      assert.match(sentimentOutput, /\[Structured Output\]\n\{.*\}/);
      assert.match(calcOutput, /\[Structured Output\]\n\{.*\}/);
    });
  });
});

// ============================================================================
// Phase 2: Integration Tests (Skipped without API key)
// ============================================================================

const hasApiKey = !!process.env.ANTHROPIC_API_KEY;

describe("Phase 2: Integration Tests", () => {
  skipIf(!hasApiKey)(
    "end-to-end: agent generates text with structured output parsing",
    async () => {
      // Given: Agent configured with output schema
      const outputSchema = z.object({
        sentiment: z.enum(["positive", "negative", "neutral"]),
        confidence: z.number().min(0).max(1),
      });

      const backend = new StateBackend({ todos: [], files: {} });
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        systemPrompt: "Analyze sentiment. Return structured output with sentiment and confidence.",
        tools: { sentiment: createSentimentTool() },
        output: {
          schema: outputSchema,
          description: "Sentiment analysis result",
        },
      });

      // When: Agent generates response
      const result = await agent.generate({
        prompt: "The product is excellent and very reliable!",
      });

      // Then: Result should include text and potentially structured output
      assert.notStrictEqual(result, undefined);
      assert.notStrictEqual(result.text, undefined);
      // Note: Actual structured output depends on ToolLoopAgent's native support
    },
    { timeout: 30000 }
  );

  skipIf(!hasApiKey)(
    "end-to-end: subagent with structured output delegates and formats correctly",
    async () => {
      // Given: Parent agent with subagent that has output schema
      const backend = new StateBackend({ todos: [], files: {} });
      const agent = createDeepAgent({
        model: anthropic("claude-haiku-4-5-20251001"),
        backend,
        systemPrompt: "Delegate to sentiment analyzer and summarize its findings.",
        tools: {
          sentiment: createSentimentTool(),
        },
      });

      // When: Agent delegates to subagent (would use task tool in real scenario)
      // Then: Subagent output should be formatted for parent consumption
      assert.notStrictEqual(agent, undefined);
    },
    { timeout: 30000 }
  );
});

