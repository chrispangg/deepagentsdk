/**
 * BDD Tests: Model Parser (Current Implementation + New Features)
 *
 * Tests for model parser with custom configuration support.
 *
 * Generated by: /3_define_test_cases
 * Last updated: 2026-01-18
 * Test coverage: Current functionality + configuration management
 */

import { test, beforeEach, describe } from "node:test";
import assert from "node:assert/strict";
import {
  parseModelString,
  setProvidersConfig,
  getProvidersConfig,
} from "@/utils/model-parser";

beforeEach(() => {
  // Reset global config before each test
  setProvidersConfig({});
});

// ============================================================================
// Phase 1: Core Functionality (Current Implementation)
// ============================================================================

describe("Phase 1: Core parseModelString functionality", () => {
  test("parses anthropic model string with full specification", () => {
    // Given: Full model string with provider and model name

    // When: Parsing the model string
    const model = parseModelString("anthropic/claude-sonnet-4-20250514");

    // Then: Should return a LanguageModel instance
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("parses openai model string with full specification", () => {
    // Given: Full model string with provider and model name

    // When: Parsing the model string
    const model = parseModelString("openai/gpt-4o");

    // Then: Should return a LanguageModel instance
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("parses zhipu model string with full specification", () => {
    // Given: Full model string with provider and model name

    // When: Parsing the model string
    const model = parseModelString("zhipu/glm-4-plus");

    // Then: Should return a LanguageModel instance
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("defaults to anthropic when no provider specified", () => {
    // Given: Model string without provider prefix

    // When: Parsing the model string
    const model = parseModelString("claude-3-sonnet-20240229");

    // Then: Should default to Anthropic provider
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("uses default model name for anthropic when model is empty", () => {
    // Given: Provider specified without model name

    // When: Parsing the model string
    const model = parseModelString("anthropic/");

    // Then: Should use default model name
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("uses default model name for openai when model is empty", () => {
    // Given: Provider specified without model name

    // When: Parsing the model string
    const model = parseModelString("openai/");

    // Then: Should use default model name
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("uses default model name for zhipu when model is empty", () => {
    // Given: Provider specified without model name

    // When: Parsing the model string
    const model = parseModelString("zhipu/");

    // Then: Should use default model name
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("handles empty string input", () => {
    // Given: Empty model string

    // When: Parsing the model string
    const model = parseModelString("");

    // Then: Should return anthropic with empty model
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });

  test("handles multiple slashes in model string", () => {
    // Given: Model string with multiple slashes

    // When: Parsing the model string
    const model = parseModelString("anthropic/claude/sonnet");

    // Then: First part is provider, rest is model
    assert.notStrictEqual(model, undefined);
    assert.strictEqual(typeof model, "object");
  });
});
