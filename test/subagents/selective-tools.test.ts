/**
 * BDD Tests: Subagent Selective Builtin Tools
 *
 * Tests the ability to configure subagents with specific builtin tools
 * rather than inheriting all or none of the parent's tools.
 *
 * Generated by: /3_define_test_cases
 * Last updated: 2025-12-20
 * Test coverage: Individual builtin tool selection for subagents
 */

import { test, describe, beforeEach, afterEach, mock } from "node:test";
import { createDeepAgent } from "@/agent";
import { createSubagentTool } from "@/tools/subagent";
import type { DeepAgentState, SubAgent } from "@/types";
import type { ToolSet } from "ai";
import { tool } from "ai";
import { z } from "zod";
import { StateBackend } from "@/backends/state";
import assert from "node:assert/strict";
import {
  web_search,
  http_request,
  fetch_url,
  ls,
  read_file,
  write_file,
  edit_file,
  glob,
  grep,
  write_todos,
  execute
} from "@/tools/index";

// ============================================================================
// Test Helpers (Used 3+ times across tests)
// ============================================================================

/** Creates mock DeepAgent state for testing */
function createMockState(): DeepAgentState {
  return {
    files: {},
    todos: [],
  };
}

/** Creates event collector for tracking tool events */
function createEventCollector() {
  const events: any[] = [];
  const onEvent = (event: any) => events.push(event);
  return { events, onEvent };
}

/** Creates mock language model for testing */
const mockModel = {
  provider: "test",
  modelId: "test-model",
  specificationVersion: "v3" as const,
  supportedUrls: async () => ({}),
  doGenerate: async () => ({
    text: "Mock response",
    usage: { totalTokens: 10, promptTokens: 5, completionTokens: 5 },
    finishReason: "stop",
  }),
  doStream: async function* () {
    yield { type: "text-delta", textDelta: "Mock" };
    yield { type: "finish", finishReason: "stop", usage: { totalTokens: 10 } };
  },
};

/** Creates mock tool for testing */
function createMockTool(name: string) {
  return tool({
    description: `Mock tool: ${name}`,
    inputSchema: z.object({ input: z.string() }),
    execute: async ({ input }) => `Result from ${name}: ${input}`,
  });
}

/** Creates mock backend for testing */
function createMockBackend(state?: DeepAgentState) {
  return new StateBackend(state ?? createMockState());
}

// ============================================================================
// Phase 1: Individual Tool Exports
// ============================================================================

describe("Individual Builtin Tool Exports", () => {
  test("exports individual web tools", async () => {
    // Given: Individual web tools are imported
    assert.notStrictEqual(web_search, undefined);
    assert.notStrictEqual(http_request, undefined);
    assert.notStrictEqual(fetch_url, undefined);

    // Then: Each tool should be a function (tool creator)
    assert.strictEqual(typeof web_search, "function");
    assert.strictEqual(typeof http_request, "function");
    assert.strictEqual(typeof fetch_url, "function");
  });

  test("exports individual filesystem tools", async () => {
    // Given: Individual filesystem tools are imported
    assert.notStrictEqual(ls, undefined);
    assert.notStrictEqual(read_file, undefined);
    assert.notStrictEqual(write_file, undefined);
    assert.notStrictEqual(edit_file, undefined);
    assert.notStrictEqual(glob, undefined);
    assert.notStrictEqual(grep, undefined);

    // Then: Each tool should be a function (tool creator)
    assert.strictEqual(typeof ls, "function");
    assert.strictEqual(typeof read_file, "function");
    assert.strictEqual(typeof write_file, "function");
  });

  test("exports individual utility tools", async () => {
    // Given: Individual utility tools are imported
    assert.notStrictEqual(write_todos, undefined);
    assert.notStrictEqual(execute, undefined);

    // Then: Each tool should be a function (tool creator)
    assert.strictEqual(typeof write_todos, "function");
    assert.strictEqual(typeof execute, "function");
  });
});

// ============================================================================
// Phase 2: Subagent Configuration with Individual Tools
// ============================================================================

describe("Subagent Tool Configuration", () => {
  let mockState: DeepAgentState;
  let mockBackend: StateBackend;
  let { events, onEvent } = createEventCollector();

  beforeEach(() => {
    mockState = createMockState();
    mockBackend = createMockBackend();
    const collector = createEventCollector();
    events = collector.events;
    onEvent = collector.onEvent;
  });

  test("configures subagent with single web tool", async () => {
    // Given: Subagent configuration with web_search tool only
    const subagent: SubAgent = {
      name: "web-researcher",
      description: "Researches topics on the web",
      systemPrompt: "You are a web research specialist",
      tools: [web_search] // Only web search tool
    };

    // When: Creating agent with configured subagent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: mockBackend,
      subagents: [
        subagent
      ]
    });

    // Then: Agent should be created successfully
    assert.notStrictEqual(agent, undefined);

    // And: Subagent should be registered
    const agentWithSubagents = agent as any;
    assert.notStrictEqual(agentWithSubagents.subagentOptions, undefined);
    assert.notStrictEqual(agentWithSubagents.subagentOptions.subagents, undefined);
    assert.ok(Array.isArray(agentWithSubagents.subagentOptions.subagents));
  });

  test("configures subagent with multiple filesystem tools", async () => {
    // Given: Subagent configuration with selected filesystem tools
    const subagent: SubAgent = {
      name: "file-manager",
      description: "Manages workspace files",
      systemPrompt: "You help with file operations",
      tools: [read_file, write_file, ls] // Only specific filesystem tools
    };

    // When: Creating agent with configured subagent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: mockBackend,
      subagents: [
        subagent
      ]
    });

    // Then: Agent should be created successfully
    assert.notStrictEqual(agent, undefined);
  });

  test("configures subagent with mixed tool types", async () => {
    // Given: Subagent configuration with mixed builtin and custom tools
    const customTool = createMockTool("custom");
    const subagent: SubAgent = {
      name: "hybrid-agent",
      description: "Agent with mixed tools",
      systemPrompt: "You have various tools available",
      tools: [web_search, read_file, write_todos, { custom_tool: customTool }]
    };

    // When: Creating agent with configured subagent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: mockBackend,
      subagents: [
        subagent
      ]
    });

    // Then: Agent should be created successfully
    assert.notStrictEqual(agent, undefined);
  });

  test("configures multiple subagents with different tool sets", async () => {
    // Given: Multiple subagents with different tool configurations
    const webResearcher: SubAgent = {
      name: "web-researcher",
      description: "Handles web research",
      systemPrompt: "You research using web tools",
      tools: [web_search, http_request]
    };

    const fileManager: SubAgent = {
      name: "file-manager",
      description: "Manages files",
      systemPrompt: "You manage files",
      tools: [ls, read_file, write_file]
    };

    const taskPlanner: SubAgent = {
      name: "task-planner",
      description: "Plans tasks",
      systemPrompt: "You plan and track tasks",
      tools: [write_todos]
    };

    // When: Creating agent with all subagents
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: mockBackend,
      subagents: [webResearcher, fileManager, taskPlanner]
    });

    // Then: Agent should be created with all subagents
    assert.notStrictEqual(agent, undefined);
    const agentWithSubagents = agent as any;
    assert.notStrictEqual(agentWithSubagents.subagentOptions.subagents, undefined);
    assert.strictEqual(agentWithSubagents.subagentOptions.subagents.length, 3);
  });
});

// ============================================================================
// Phase 3: Default Behavior (Backward Compatibility)
// ============================================================================

describe("Default Behavior and Backward Compatibility", () => {
  test("maintains default behavior when no tools specified", async () => {
    // Given: Subagent without tool specification
    const subagent: SubAgent = {
      name: "default-agent",
      description: "Agent with default tools",
      systemPrompt: "You have default tools"
      // No tools specified
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent without errors
    assert.notStrictEqual(agent, undefined);
  });

  test("accepts legacy ToolSet format for tools", async () => {
    // Given: Subagent with legacy ToolSet format
    const customTools: ToolSet = {
      legacy_tool: createMockTool("legacy"),
      another_tool: createMockTool("another")
    };

    const subagent: SubAgent = {
      name: "legacy-agent",
      description: "Agent with legacy tool format",
      systemPrompt: "You use legacy tool format",
      tools: customTools // ToolSet object, not array
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent without errors
    assert.notStrictEqual(agent, undefined);
  });

  test("accepts empty tools array", async () => {
    // Given: Subagent with explicitly empty tools array
    const subagent: SubAgent = {
      name: "minimal-agent",
      description: "Agent with no tools",
      systemPrompt: "You have no tools available",
      tools: [] // Explicitly empty
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent without errors
    assert.notStrictEqual(agent, undefined);
  });
});

// ============================================================================
// Phase 4: Error Handling and Edge Cases
// ============================================================================

describe("Error Handling and Edge Cases", () => {
  test("handles null tools gracefully", async () => {
    // Given: Subagent with null tools
    const subagent: SubAgent = {
      name: "null-tools-agent",
      description: "Agent with null tools",
      systemPrompt: "You have null tools",
      tools: null as any // Explicitly null
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent without errors
    assert.notStrictEqual(agent, undefined);
  });

  test("handles undefined tools gracefully", async () => {
    // Given: Subagent with undefined tools
    const subagent: SubAgent = {
      name: "undefined-tools-agent",
      description: "Agent with undefined tools",
      systemPrompt: "You have undefined tools",
      tools: undefined // Explicitly undefined
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent without errors
    assert.notStrictEqual(agent, undefined);
  });

  test("handles invalid tool objects in array", async () => {
    // Given: Subagent with invalid tool mixed with valid tools
    const subagent: SubAgent = {
      name: "mixed-tools-agent",
      description: "Agent with mixed valid/invalid tools",
      systemPrompt: "You have mixed tools",
      tools: [
        web_search, // Valid
        { invalid: "tool" } as any, // Invalid
        read_file // Valid
      ]
    };

    // When/Then: Should handle gracefully (implementation dependent)
    // This test documents the expected behavior - actual error handling
    // may vary based on implementation
    assert.doesNotThrow(() => {
      const agent = createDeepAgent({
        model: mockModel as any,
        backend: createMockBackend(),
        subagents: [
          subagent
        ]
      });
      // Either creates successfully or throws meaningful error
      assert.notStrictEqual(agent, undefined);
    });
  });
});

// ============================================================================
// Phase 5: Type Safety and TypeScript Integration
// ============================================================================

describe("Type Safety and TypeScript Integration", () => {
  test("provides correct TypeScript types for individual tools", () => {
    // Given: Imported individual tools
    // Then: TypeScript should infer correct types (functions, not objects)
    assert.strictEqual(typeof web_search, "function");
    assert.strictEqual(web_search.name, "createWebSearchTool");
  });

  test("allows tool arrays in subagent configuration", () => {
    // Given: Type checking should allow array of tools
    const subagent: SubAgent = {
      name: "typed-agent",
      description: "Agent with typed tools",
      systemPrompt: "You have typed tools",
      tools: [web_search, read_file] // TypeScript should accept this
    };

    assert.notStrictEqual(subagent.tools, undefined);
    assert.ok(Array.isArray(subagent.tools));
  });

  test("maintains type safety with mixed tool formats", () => {
    // Given: Subagent with mixed tool formats
    const customTools: ToolSet = {
      custom_tool: createMockTool("custom")
    };

    const subagent: SubAgent = {
      name: "mixed-type-agent",
      description: "Agent with mixed type tools",
      systemPrompt: "You have mixed type tools",
      tools: [web_search, customTools] // Should be type-safe
    };

    assert.notStrictEqual(subagent.tools, undefined);
  });
});

// ============================================================================
// Phase 6: Integration with Existing Features
// ============================================================================

describe("Integration with Existing Features", () => {
  test("works with generation options", async () => {
    // Given: Subagent with tools and generation options
    const subagent: SubAgent = {
      name: "configured-agent",
      description: "Agent with tools and options",
      systemPrompt: "You are fully configured",
      tools: [web_search, read_file],
      generationOptions: {
        temperature: 0.1,
        maxOutputTokens: 1000
      },
      advancedOptions: {
        experimental_telemetry: { isEnabled: true }
      }
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      generationOptions: {
        temperature: 0.7 // Parent option
      },
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent with all configurations
    assert.notStrictEqual(agent, undefined);
  });

  test("works with structured output", async () => {
    // Given: Subagent with tools and structured output
    const outputSchema = {
      schema: z.object({
        result: z.string(),
        confidence: z.number()
      }),
      description: "Research findings with confidence score"
    };

    const subagent: SubAgent = {
      name: "structured-agent",
      description: "Agent with structured output",
      systemPrompt: "You provide structured output",
      tools: [read_file, write_todos],
      output: outputSchema
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent with structured output
    assert.notStrictEqual(agent, undefined);
  });

  test("works with interrupt configuration", async () => {
    // Given: Subagent with tools and interrupt config
    const subagent: SubAgent = {
      name: "interruptible-agent",
      description: "Agent with interruptible tools",
      systemPrompt: "Your tools may require approval",
      tools: [web_search, execute], // Tools that might need approval
      interruptOn: {
        web_search: true, // Require approval for web searches
        execute: true // Require approval for code execution
      }
    };

    // When: Creating agent
    const agent = createDeepAgent({
      model: mockModel as any,
      backend: createMockBackend(),
      subagents: [
        subagent
      ]
    });

    // Then: Should create agent with interrupt configuration
    assert.notStrictEqual(agent, undefined);
  });
});